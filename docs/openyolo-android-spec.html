<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>OpenYOLO for Android</title><script type="application/javascript">
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          var postfix = fragid.substring(2);
          if (postfix.startsWith("abstract")) {
            window.location.hash = prefix + postfix;
          } else if (postfix.startsWith("note-")) {
            window.location.hash = prefix + "note." + postfix.substring(5);
          } else {
            window.location.hash = prefix + "section." + postfix;
          }
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script><link rel="shortcut icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAADnUExURf////r6+r+/v/f39/3nzrS0tP7+/rOzs/iTHvmnR+vr6/j4+LW1tebm5urq6tvb2/z8/Lm5uc7OztnZ2fDw8MHBweTk5P/59Li4uLe3t7y8vLa2tv39/b29vdDQ0PjkzL6+vsO+ucPDw8vLy+/v7+Dg4PiWI/q6bvmoSeLi4v7z5vHx8fn5+fvBfv7x4tfX1/v7++7u7ujo6NPT08XFxeXl5fzUpuPj497e3sLCwru7u/mcMfvlzfzmzvzNl//79tLS0tra2szMzOnp6c3Nzdzc3PDq5d3d3fmbL+Hh4eDSw8bGxtXV1TGsX/AAAAD6SURBVDjLY2CgAdDCL62nroFPWlxXjYMTnwIWDo5Br4DZFqSAWwCrJCOvgwK7PEgBP6uSDx+6tICjNDsQQBSAWKK8DIZCCHkxKZCgpJMNSAGfLIjDasIuCJfXB4koOcvAHMnlwmMlCVTDBpVXBUpLW7Ah+ULEEqSFnRsiz8UKZBshe5NbDmwLuzZEgTKQKYweDsymxqKsEL+wSQAV6GALKANGMKUClGfCF5IihBSwCQJVMOOLCyFsjkQGYG+K4YtNTaACHnc2PNENjh4FXgHc6cEcHFk83l44E4yMKyi42BU5OKzNcKQmRk85JnZFDzt7fEmS0U2c+lkZAOAoE2iFNzVGAAAAAElFTkSuQmCC"><meta name="theme-color" content="#f38019"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><style type="text/css">
    @import url('https://fonts.googleapis.com/css?family=Noto+Sans:r,b,i,bi');
    @import url('https://fonts.googleapis.com/css?family=Roboto+Mono:r,b,i,bi');

    body {
      background-color: #fafafa;
      color: #5a5a5a;
      font-family: 'Noto Sans', sans-serif;
      font-size: 12pt;
      margin: 1em;
      overflow-wrap: break-word;
    }

    body > * {
      max-width: 50em;
      margin: auto;
      overflow-x: hidden;
    }

    #identifiers {
      margin: 8pt 0;
    }

    #identifiers > div {
    }

    #identifiers dt {
      display: inline;
      float: none;
      font-style: italic;
      vertical-align: top;
    }

    #identifiers dt:after {
      content: ": ";
      vertical-align: top;
    }

    #identifiers dd {
      display: inline;
      margin: 0;
    }

    .authors {
      display: block;
      text-align: center;
      margin-top: 0.5em;
    }

    .authors .author {
      display: inline-block;
      margin-right: 1.5em;
    }

    .authors .org {
      font-style: italic;
    }

    a {
      text-decoration: none;
      color: #f38019
    }

    a.smpl {
      color: black;
    }

    a:hover {
      text-decoration: underline;
    }

    a:active {
      text-decoration: underline;
    }

    .self {
        color: #999999;
        margin-left: .3em;
        text-decoration: none;
        visibility: hidden;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
    }
    .self:hover {
        text-decoration: none;
    }
    li:hover > a.self, p:hover > a.self {
        visibility: visible;
    }

    address {
      margin-top: 1em;
      margin-left: 2em;
      font-style: normal;
    }

    

    samp, span.tt, code, pre {
      font-family: 'Roboto Mono', monospace;
    }

    

    cite {
      font-style: normal;
    }

    dl > dt {
      float: left;
      margin-right: 1em;
    }
    dl.nohang > dt {
      float: none;
    }
    dl > dd {
      margin-bottom: .5em;
    }
    dl.compact > dd {
      margin-bottom: .0em;
    }
    dl > dd > dl {
      margin-top: 0.5em;
    }
    ul.empty {
      list-style-type: none;
    }
    ul.empty li {
      margin-top: .5em;
    }
    dl p {
      margin-left: 0em;
    }
    dl.reference > dt {
      font-weight: bold;
    }

    h1 {
      color: #f38019;
      font-size: 150%;
      line-height: 18pt;
      font-weight: bold;
      text-align: center;
      margin-top: 8pt;
      margin-bottom: 0pt;
    }
    h2 {
      font-size: 130%;
      line-height: 21pt;
      page-break-after: avoid;
    }
    h2.np {
      page-break-before: always;
    }
    h3 {
      font-size: 120%;
      line-height: 15pt;
      page-break-after: avoid;
    }
    h4 {
      font-size: 110%;
      page-break-after: avoid;
    }
    h5, h6 {
      page-break-after: avoid;
    }
    h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
      color: black;
    }

    ol.la {
      list-style-type: lower-alpha;
    }
    ol.ua {
      list-style-type: upper-alpha;
    }
    ol p {
      margin-left: 0em;
    }
    

    pre {
      font-size: 11pt;
      background-color: #E0E0E0;
      padding: .25em;
      page-break-inside: avoid;
      overflow-x: auto;
    }

    

    pre.text2 {
      border-style: dotted;
      border-width: 1px;
      background-color: #E0E0E0;
    }
    pre.inline {
      background-color: white;
      padding: 0em;
      page-break-inside: auto;
      
    }
    pre.text {
      border-style: dotted;
      border-width: 1px;
      background-color: #fafafa;
    }
    pre.drawing {
      border-style: solid;
      border-width: 1px;
      background-color: #fafafa;
      padding: 2em;
    }

    

    table.header {
      border-spacing: 1px;
      width: 95%;
      font-size: 11pt;
      color: white;
    }
    td.top {
      vertical-align: top;
    }
    td.topnowrap {
      vertical-align: top;
      white-space: nowrap;
    }
    table.header td {
      background-color: #7c7d80;
      width: 50%;
      padding: 2px 8px;
    }

    

    ul.toc, ul.toc ul {
      list-style: none;
      padding-left: 0em;
    }

    ul.toc li {
      line-height: 150%;
      font-weight: bold;
      margin-left: 0em;
    }

    ul.toc li li {
      line-height: normal;
      font-weight: normal;
      font-size: 11pt;
      margin-left: 0em;
    }

    ul.toc a {
      color: #f38019;
    }

    li.excluded {
      font-size: 0pt;
    }
    ul p {
      margin-left: 0em;
    }
    .filename, h1, h2, h3, h4 {
      font-family: 'Noto Sans', segoe, optima, arial, sans-serif;
    }

    

    .comment {
      background-color: yellow;
    }

    

    .center {
      text-align: center;
    }

    .error {
      color: red;
      font-style: italic;
      font-weight: bold;
    }
    .figure {
      font-weight: bold;
      text-align: center;
      font-size: 10pt;
    }
    .filename {
      color: #5a5a5a;
      font-size: 112%;
      font-weight: bold;
      line-height: 21pt;
      text-align: center;
      margin-top: 0.25em;
    }
    .fn {
      font-weight: bold;
    }
    .left {
      text-align: left;
    }
    .right {
      text-align: right;
    }
    .warning {
      font-size: 130%;
      background-color: yellow;
    }

    

    @media screen {
      pre.text, pre.text2 {
        width: 69em;
      }
    }

    @media print {
      .noprint {
        display: none;
      }

      a {
        color: black;
        text-decoration: none;
      }

      table.header {
        width: 90%;
      }

      td.header {
        width: 50%;
        color: black;
        background-color: white;
        vertical-align: top;
        font-size: 110%;
      }

      ul.toc a:last-child::after {
        content: leader('.') target-counter(attr(href), page);
      }

      ul.ind li li a {
        content: target-counter(attr(href), page);
      }

      pre {
        font-size: 10pt;
      }

      .print2col {
        column-count: 2;
        -moz-column-count: 2;
        column-fill: auto;
      }

    
    }

    @page {
      @top-left {
          content: "Internet-Draft";
      }
      @top-right {
          content: "April 2017";
      }
      @top-center {
          content: "OpenYOLO for Android";
      }
      @bottom-left {
          content: "McGinniss";
      }
      @bottom-center {
          content: "Expires October 26, 2017";
      }
      @bottom-right {
          content: "[Page " counter(page) "]";
      }
    }
    @page:first {
        @top-left {
          content: normal;
        }
        @top-right {
          content: normal;
        }
        @top-center {
          content: normal;
        }
    }

    @media only screen and (max-device-width: 480px) {
      p {
        text-align: justify;
        text-justify: distribute;
        -webkit-hyphens: auto;
      }

      pre {
        font-size: 9pt;
      }

      table.header {
        display: block;
        border-spacing: 1px;
        font-size: 11pt;
        color: white;
      }

      table.header tbody {
        display: flex;
        flex-direction: column;
      }

      table.header tr {
        display: run-in;
      }

      table.header td {
        display: block;
        background-color: #7c7d80;
        width: auto;
      }

      table.header td.left {
        order: 0;
      }

      table.header td.right {
        order: 1;
      }
    }
    </style><link rel="Contents" href="#rfc.toc"><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 OpenYOLO concepts and definitions" href="#rfc.section.2"><link rel="Chapter" title="3 Operations" href="#rfc.section.3"><link rel="Chapter" title="4 OpenYOLO on Android" href="#rfc.section.4"><link rel="Chapter" title="5 Saving credentials" href="#rfc.section.5"><link rel="Chapter" title="6 The Android Application Programming Interface (API)" href="#rfc.section.6"><link rel="Chapter" title="7 The Android Service Provider Interface (SPI)" href="#rfc.section.7"><meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.908, 2017/04/06 12:58:20, XSLT vendor: Saxonica http://www.saxonica.com/"><meta name="keywords" content="password, credential, security"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="McGinniss, I."><meta name="dcterms.identifier" content="urn:ietf:id:draft-openyolo-android-00"><meta name="dcterms.issued" content="2017-04-24"><meta name="dcterms.abstract" content="OpenYOLO for Android is a protocol for retrieving, updating and assisting in the creation of authentication credentials. This document describes the core concepts of OpenYOLO, and the platform-specific details for implementing the OpenYOLO protocol on Android. What's in a name? YOLO stands for &#34;You Only Login Once&#34;, which was the internal code-name for Google's Smart Lock for Passwords API on Android. OpenYOLO is the open standard successor to YOLO - lessons learned from the implementation and usage of Smart Lock for Passwords have heavily influenced this specification."><meta name="description" content="OpenYOLO for Android is a protocol for retrieving, updating and assisting in the creation of authentication credentials. This document describes the core concepts of OpenYOLO, and the platform-specific details for implementing the OpenYOLO protocol on Android. What's in a name? YOLO stands for &#34;You Only Login Once&#34;, which was the internal code-name for Google's Smart Lock for Passwords API on Android. OpenYOLO is the open standard successor to YOLO - lessons learned from the implementation and usage of Smart Lock for Passwords have heavily influenced this specification."></head><body><header><div id="rfc.title"><h1>OpenYOLO for Android</h1><div class="filename">draft-openyolo-android-00</div></div><div class="authors"><div class="author"><div class="author-name">I. McGinniss</div><div class="org">Google, Inc.</div></div></div><dl id="identifiers"><div><dt>Stream</dt><dd class="workgroup">Account Chooser</dd></div><div><dt>Category</dt><dd>Experimental</dd></div><div><dt>Published</dt><dd>April&nbsp;24, 2017</dd></div><div><dt>Expires</dt><dd>October 26, 2017</dd></div></dl></header><section id="rfc.abstract"><h2><a href="#rfc.abstract">Abstract</a></h2><div id="rfc.abstract.p.1"><p>OpenYOLO for Android is a protocol for retrieving, updating and assisting in the creation of authentication credentials. This document describes the core concepts of OpenYOLO, and the platform-specific details for implementing the OpenYOLO protocol on Android.</p></div><div id="rfc.abstract.p.2"><p><strong>What's in a name?</strong> </p></div><div id="rfc.abstract.p.3"><p>YOLO stands for "You Only Login Once", which was the internal code-name for Google's <a href="https://developers.google.com/identity/smartlock-passwords/android/">Smart Lock for Passwords</a> API on Android. OpenYOLO is the open standard successor to YOLO - lessons learned from the implementation and usage of Smart Lock for Passwords have heavily influenced this specification.</p></div></section><hr class="noprint"><nav id="rfc.toc"><h2 class="np"><a href="#rfc.toc">Table of Contents</a></h2><ul class="toc"><li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#password-authentication">Password authentication</a></li><li><a href="#rfc.section.1.2">1.2.</a>&nbsp;&nbsp;&nbsp;<a href="#federated-authentication">Federated authentication</a></li><li><a href="#rfc.section.1.3">1.3.</a>&nbsp;&nbsp;&nbsp;<a href="#account-recovery-based-authentication">Account recovery based authentication</a></li><li><a href="#rfc.section.1.4">1.4.</a>&nbsp;&nbsp;&nbsp;<a href="#credential-managers">Credential managers</a></li><li><a href="#rfc.section.1.5">1.5.</a>&nbsp;&nbsp;&nbsp;<a href="#solution-direct-communication-with-a-credential-manager">Solution: Direct communication with a credential manager</a></li></ul></li><li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#openyolo-concepts-and-definitions">OpenYOLO concepts and definitions</a><ul><li><a href="#rfc.section.2.1">2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#credentials">Credentials</a><ul><li><a href="#rfc.section.2.1.1">2.1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#hints">Hints</a></li></ul></li><li><a href="#rfc.section.2.2">2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#credential-providers">Credential providers</a><ul><li><a href="#rfc.section.2.2.1">2.2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#known-unknown-and-preferred-providers">Known, unknown and preferred providers</a></li></ul></li><li><a href="#rfc.section.2.3">2.3.</a>&nbsp;&nbsp;&nbsp;<a href="#token-providers">Token providers</a></li><li><a href="#rfc.section.2.4">2.4.</a>&nbsp;&nbsp;&nbsp;<a href="#authentication-domains">Authentication domains</a></li><li><a href="#rfc.section.2.5">2.5.</a>&nbsp;&nbsp;&nbsp;<a href="#authentication-methods">Authentication methods</a></li><li><a href="#rfc.section.2.6">2.6.</a>&nbsp;&nbsp;&nbsp;<a href="#password-specifications">Password specifications</a></li><li><a href="#rfc.section.2.7">2.7.</a>&nbsp;&nbsp;&nbsp;<a href="#client-versions">Client versions</a></li></ul></li><li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#operations">Operations</a><ul><li><a href="#rfc.section.3.1">3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#hint-retrieval">Hint retrieval</a><ul><li><a href="#rfc.section.3.1.1">3.1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#hint-request-message">Hint request message</a></li><li><a href="#rfc.section.3.1.2">3.1.2.</a>&nbsp;&nbsp;&nbsp;<a href="#hint-response-message">Hint response message</a></li><li><a href="#rfc.section.3.1.3">3.1.3.</a>&nbsp;&nbsp;&nbsp;<a href="#example-hint-retrieval-scenario">Example hint retrieval scenario</a></li></ul></li><li><a href="#rfc.section.3.2">3.2.</a>&nbsp;&nbsp;&nbsp;<a href="#credential-retrieval">Credential retrieval</a><ul><li><a href="#rfc.section.3.2.1">3.2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#credential-request-message">Credential request message</a></li><li><a href="#rfc.section.3.2.2">3.2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#credential-response-message">Credential response message</a></li><li><a href="#rfc.section.3.2.3">3.2.3.</a>&nbsp;&nbsp;&nbsp;<a href="#example-credential-retrieval-scenario">Example credential retrieval scenario</a></li></ul></li><li><a href="#rfc.section.3.3">3.3.</a>&nbsp;&nbsp;&nbsp;<a href="#credential-saving">Credential saving</a><ul><li><a href="#rfc.section.3.3.1">3.3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#save-request-message">Save request message</a></li><li><a href="#rfc.section.3.3.2">3.3.2.</a>&nbsp;&nbsp;&nbsp;<a href="#save-response-message">Save response message</a></li><li><a href="#rfc.section.3.3.3">3.3.3.</a>&nbsp;&nbsp;&nbsp;<a href="#example-credential-save-scenario">Example credential save scenario</a></li></ul></li><li><a href="#rfc.section.3.4">3.4.</a>&nbsp;&nbsp;&nbsp;<a href="#credential-deletion">Credential deletion</a><ul><li><a href="#rfc.section.3.4.1">3.4.1.</a>&nbsp;&nbsp;&nbsp;<a href="#delete-request-message">Delete request message</a></li><li><a href="#rfc.section.3.4.2">3.4.2.</a>&nbsp;&nbsp;&nbsp;<a href="#delete-response-message">Delete response message</a></li><li><a href="#rfc.section.3.4.3">3.4.3.</a>&nbsp;&nbsp;&nbsp;<a href="#example-credential-deletion-scenario">Example credential deletion scenario</a></li></ul></li></ul></li><li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#openyolo-on-android">OpenYOLO on Android</a><ul><li><a href="#rfc.section.4.1">4.1.</a>&nbsp;&nbsp;&nbsp;<a href="#discovering-installed-providers">Discovering installed providers</a></li><li><a href="#rfc.section.4.2">4.2.</a>&nbsp;&nbsp;&nbsp;<a href="#preferred-credential-providers-on-android">Preferred credential providers on Android</a></li><li><a href="#rfc.section.4.3">4.3.</a>&nbsp;&nbsp;&nbsp;<a href="#background-broadcast-query-protocol-bbq">Background broadcast query protocol (BBQ)</a><ul><li><a href="#rfc.section.4.3.1">4.3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#structure-of-a-request">Structure of a request</a></li><li><a href="#rfc.section.4.3.2">4.3.2.</a>&nbsp;&nbsp;&nbsp;<a href="#dispatching-a-request">Dispatching a request</a></li><li><a href="#rfc.section.4.3.3">4.3.3.</a>&nbsp;&nbsp;&nbsp;<a href="#structure-of-a-response">Structure of a response</a></li><li><a href="#rfc.section.4.3.4">4.3.4.</a>&nbsp;&nbsp;&nbsp;<a href="#receiving-a-response">Receiving a response</a></li><li><a href="#rfc.section.4.3.5">4.3.5.</a>&nbsp;&nbsp;&nbsp;<a href="#security-on-rooted-devices">Security on rooted devices</a></li></ul></li><li><a href="#rfc.section.4.4">4.4.</a>&nbsp;&nbsp;&nbsp;<a href="#retrieving-hints">Retrieving Hints</a></li><li><a href="#rfc.section.4.5">4.5.</a>&nbsp;&nbsp;&nbsp;<a href="#retrieving-credentials">Retrieving credentials</a></li><li><a href="#rfc.section.4.6">4.6.</a>&nbsp;&nbsp;&nbsp;<a href="#retrieve-request-messages">Retrieve request messages</a></li><li><a href="#rfc.section.4.7">4.7.</a>&nbsp;&nbsp;&nbsp;<a href="#retrieve-response-messages">Retrieve response messages</a></li><li><a href="#rfc.section.4.8">4.8.</a>&nbsp;&nbsp;&nbsp;<a href="#retrieve-intent-responses">Retrieve intent responses</a></li></ul></li><li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#saving-credentials">Saving credentials</a><ul><li><a href="#rfc.section.5.1">5.1.</a>&nbsp;&nbsp;&nbsp;<a href="#supporting-save">Supporting save</a></li><li><a href="#rfc.section.5.2">5.2.</a>&nbsp;&nbsp;&nbsp;<a href="#filtering-the-provider-list">Filtering the provider list</a></li><li><a href="#rfc.section.5.3">5.3.</a>&nbsp;&nbsp;&nbsp;<a href="#behavior-of-the-save-intent">Behavior of the save intent</a></li><li><a href="#rfc.section.5.4">5.4.</a>&nbsp;&nbsp;&nbsp;<a href="#save-response">Save response</a></li></ul></li><li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#the-android-application-programming-interface-api">The Android Application Programming Interface (API)</a></li><li><a href="#rfc.section.7">7.</a>&nbsp;&nbsp;&nbsp;<a href="#the-android-service-provider-interface-spi">The Android Service Provider Interface (SPI)</a></li><li><a href="#rfc.authors">Author's Address</a></li></ul></nav><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><div id="rfc.boilerplate.1.p.1"><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p></div><div id="rfc.boilerplate.1.p.2"><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p></div><div id="rfc.boilerplate.1.p.3"><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p></div><div id="rfc.boilerplate.1.p.4"><p>This Internet-Draft will expire on October 26, 2017.</p></div></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><div id="rfc.boilerplate.2.p.1"><p>Copyright © 2017 IETF Trust and the persons identified as the document authors. All rights reserved.</p></div><div id="rfc.boilerplate.2.p.2"><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></div></section><hr class="noprint"><section id="introduction"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a href="#introduction">Introduction</a></h2><div id="rfc.section.1.p.1" class="avoidbreakafter"><p>Manually authenticating in an app or site is mentally exhausting. Users are typically presented with a screen like the following when interacting with services in an application or website:</p></div><pre>
+------------------------------------------+
|                                          |
|       To continue, please sign in:       |
|                                          |
|    Email                                 |
|   ------------------------------------   |
|                                          |
|    Password                              |
|   ------------------------------------   |
|                                          |
|   Forgotten your password? [Click here]  |
|                                          |
|   =============== Or: ================   |
|                                          |
|   +-------------+     +--------------+   |
|   |   Google    |     |   Facebook   |   |
|   +-------------+     +--------------+   |
|                                          |
|       If you don't have an account,      |
|                [click here]              |
|                                          |
+------------------------------------------+
</pre><div id="rfc.section.1.p.2" class="avoidbreakafter"><p>The user typically has to answer three questions in response to such a page:</p></div><div id="rfc.section.1.p.3"><ol><li>Do I already have an account for this service?</li> <li>If so, did I use an email address and password, or one of the identity provider options?</li> <li>If I used an email address and password, what was the password?<a class="self" href="#rfc.section.1.p.3">¶</a></li> </ol></div><div id="rfc.section.1.p.4"><p>For all but most frequently used applications and websites (henceforth referred to as <em>services</em>), this is a tedious and error-prone process. As of 2016, users typically interact with around <a href="https://blog.dashlane.com/infographic-online-overload-its-worse-than-you-thought/">100 services</a>, and many of those services are used less than once a month, for example to buy flowers or arrange air travel. Long session durations can help, but only when the user interacts with the service on a single device. Purchasing a new device is a particularly painful experience due to the need to re-authenticate with all used services.</p></div><div id="rfc.section.1.p.5"><p>Remembering account details for 100+ services is intractable; the natural human consequence of this situation is widespread credential reuse across services. This is a disaster for the user's security; a better solution is required.</p></div><section id="password-authentication"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a>&nbsp;<a href="#password-authentication">Password authentication</a></h3><div id="rfc.section.1.1.p.1" class="avoidbreakafter"><p>Password based authentication, despite multiple attempts to displace it, remains the most common form of authentication in use today. Password authentication suffers from three key issues:</p></div><div id="rfc.section.1.1.p.2"><ul><li><div><p>Passwords are often <em>weak</em>. Most users do not know how to produce <a href="https://doi.org/10.1109/MSP.2004.81">high entropy passwords</a>. The basic strategies employed involve using combinations of common dictionary words, years and names, all of which easily succumb to social engineering and dictionary attacks.</p></div></li> <li><div><p>Password credentials are often <em>transferable</em>. The limits of humans to memorize long strings of random information is <a href="https://doi.org/10.1145/322796.322806">well studied</a>; the typical user cannot be expected to memorize more than 5 passwords for unrelated services. The natural consequence is that users frequently reuse their passwords, which when combined with email addresses as identifiers, makes the credentials transferable across unrelated services. If a password is uncovered for a user on one service, an attacker can simply try this credential on other services with a high success rate.</p></div></li> <li><div><p>Password credentials are often <em>long lived</em>. There is no intrinsic expiration time on a password credential, and password rotation is not uniformly enforced across all password using services. If a password is uncovered by an attacker, it can be used for a significant period of time, perhaps indefinitely.</p></div><a class="self" href="#rfc.section.1.1.p.2">¶</a></li> </ul></div><div id="rfc.section.1.1.p.3"><p>Even where a service does enforce password rotation, such as once a year, "digit rotation" is commonly employed by users to circumvent this: they simply increment a counter at some position in the password, typically at the end. This makes guessing future passwords from current passwords particularly easy for an attacker.</p></div><div id="rfc.section.1.1.p.4"><p>The problems that passwords cause can only get worse, as users interact with more and more services. Yet, password authentication persists, because it is considered to be easy to implement, has no dependencies on external entities, and is familiar to users. It is unlikely that password based authentication can be completely displaced; as such, any solution in this problem space will have to fully accommodate password based authentication.</p></div></section><section id="federated-authentication"><h3 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2.</a>&nbsp;<a href="#federated-authentication">Federated authentication</a></h3><div id="rfc.section.1.2.p.1"><p>Federated authentication, in the form of <a href="https://tools.ietf.org/html/rfc6749">OAuth2</a> and <a href="http://openid.net/specs/openid-connect-core-1_0.html">OpenID Connect</a>, solves the problem of account overload by centralizing authentication for the user with a small number of trusted <em>identity providers</em>. Furthermore, by providing proof of authentication to a service (referred to as a <em>relying party</em> in this context) in the form of short lived bearer tokens and cryptographically signed <a href="https://tools.ietf.org/html/rfc7519">ID tokens</a>, overall security is significantly improved over password based authentication.</p></div><div id="rfc.section.1.2.p.2"><p>However, the success of federated authentication in the consumer space is still limited - OAuth2 and OpenID Connect are regarded as difficult to implement, and federated authentication was unnecessarily tainted by "social login" in the early 2010s. Federated authentication was associated with unnecessary and invasive sharing of personal information. This association has largely been undone, but the perception of privacy invasion lingers. As a result, many users still prefer to use password authentication over federated authentication - they feel more in control of their personal information by explicitly entering what they wish to share during account creation.</p></div><div id="rfc.section.1.2.p.3"><p>Furthermore, it is easy for users to forget <em>which</em> identity provider they use, when multiple options are presented. Services also rarely implement <em>account linking</em> correctly, where multiple authentication methods are linked to the same core account. Because of this, making the wrong choice often leads to a totally different account: for example, choosing Google Sign-in when the user's account was actually created using Facebook. The inconsistency and frustration caused by this is often enough to drive users to the authentication method they know best: password authentication, with a reused password across every service.</p></div></section><section id="account-recovery-based-authentication"><h3 id="rfc.section.1.3"><a href="#rfc.section.1.3">1.3.</a>&nbsp;<a href="#account-recovery-based-authentication">Account recovery based authentication</a></h3><div id="rfc.section.1.3.p.1" class="avoidbreakafter"><p>An equally common method of authentication employed by users is to simply trigger the <em>account recovery</em> flow every time they need to use the service. Accounts are typically created with a recovery email address or phone number, and users exploit this fact to regain access to the account when necessary. They expect the following flow:</p></div><div id="rfc.section.1.3.p.2"><ol><li><div><p>An email or SMS message will be sent containing a link to reset the password.</p></div></li> <li><div><p>The user changes the password, likely to either their current reused password, or something random that they immediately forget.</p></div></li> <li><div><p>The user is now authenticated.</p></div><a class="self" href="#rfc.section.1.3.p.2">¶</a></li> </ol></div><div id="rfc.section.1.3.p.3"><p>We shall refer to this method of authentication as "proof of access" - by demonstrating that a secret can be retrieved from some communication side-channel, the user can gain access to an account. Some services use this method explicitly, as the main form of authentication. <a href="https://www.slack.com">Slack</a> calls this "magic link" authentication.</p></div><div id="rfc.section.1.3.p.4"><p>Sending an authentication secret (a code or a link) to an email address or phone number is essentially a form of federated authentication, and the service that manages the email address is effectively the identity provider. In comparison to OpenID Connect, this is a rather absurd and inconvenient form of authentication, as it requires the user to manually drive the authentication flow. It is, however, a model of authentication that users find easy to understand, and see as privacy-preserving compared to social login.</p></div><div id="rfc.section.1.3.p.5"><p>If it were possible to provide proof of access to an email address or phone number directly to a service, then the manual verification of access to that email or phone number would be unnecessary. One may observe that the most common email providers are <em>also</em> OAuth2 or OpenID Connect identity providers: Google, Microsoft and Yahoo account for over 90% of the US market, according to a data analysis conducted by <a href="https://blog.mailchimp.com/major-email-provider-trends-in-2015-gmail-takes-a-really-big-lead/">MailChimp in 2015</a>. These providers typically already have the ability to assert proof of access in the form of <a href="https://openid.net/specs/openid-connect-core-1_0.html#IDToken">ID tokens</a>. Providing an easier mechanism to acquire such ID tokens would simplify authentication for many services.</p></div></section><section id="credential-managers"><h3 id="rfc.section.1.4"><a href="#rfc.section.1.4">1.4.</a>&nbsp;<a href="#credential-managers">Credential managers</a></h3><div id="rfc.section.1.4.p.1"><p>A <em>credential manager</em> is a piece of software that remembers credentials on behalf of a user. Most credential managers focus primarily on password based authentication, remembering the user's passwords and offering to generate strong, unique password for each new service a user interacts with.</p></div><div id="rfc.section.1.4.p.2"><p>The most common credential manager that users encounter is their web browser, which presents itself via form-fill on authentication pages. Technically knowledgeable users often also use a standalone credential manager applications, which integrate with browsers via extensions, or via input-method extensions.</p></div><div id="rfc.section.1.4.p.3" class="avoidbreakafter"><p>Credential managers suffer from some serious usability issues:</p></div><div id="rfc.section.1.4.p.4"><ul><li>When a credential manager is a standalone application, the user must typically manually switch context to find the relevant credential, and copy-paste it to the service they are signing in to. Browser extensions and input-method extensions can make this easier, but are not supported on all platforms, in particular in mobile applications and browsers.<a class="self" href="#rfc.section.1.4.p.4">¶</a></li> </ul></div><div id="rfc.section.1.4.p.5"><p>Manually copying a password also represents a security risk in itself; on some platforms it is possible for other applications installed on the device to monitor the clipboard and steal passwords that are copied out of the credential manager.</p></div><div id="rfc.section.1.4.p.6"><ul><li>Where a credential is able to integrate with the browser or OS in some way, heuristics are often necessary to detect and fill in login forms. Such heuristics are fragile to changes in the service, such as when they are redesigned or change path within the domain. Heuristics are employed because there is rarely any viable alternative: services do not provide sufficient information for a credential manager to do a better job.<a class="self" href="#rfc.section.1.4.p.6">¶</a></li> </ul></div><div id="rfc.section.1.4.p.7"><p>This problem is particularly acute when the login system employs an <em>identifier first</em> pattern, where collection of the identifier and a password are split across multiple stages. In such situations, heuristics typically fail to detect the relationship between the disparate forms.</p></div><div id="rfc.section.1.4.p.8"><ul><li><div><p>Credential managers are blind to relationships between apps and sites that share the same authentication system - saving a credential for one site does not automatically make this credential available on other, related sites.</p></div></li> <li><div><p>Credential managers are unaware of <em>federated authentication</em>: they cannot help the user remember if they signed in to the service using Google or Facebook, only whether they filled in an identifier and password.</p></div></li> <li><div><p>Credential managers are unaware of password restrictions in use on the site: how long they must be, whether they must include a number or symbol, etc. As such, <em>password generation</em> is also heuristic and based on a least common denominator schema that is acceptable to the majority of services.</p></div><a class="self" href="#rfc.section.1.4.p.8">¶</a></li> </ul></div></section><section id="solution-direct-communication-with-a-credential-manager"><h3 id="rfc.section.1.5"><a href="#rfc.section.1.5">1.5.</a>&nbsp;<a href="#solution-direct-communication-with-a-credential-manager">Solution: Direct communication with a credential manager</a></h3><div id="rfc.section.1.5.p.1" class="avoidbreakafter"><p>If services could directly communicate with the user's preferred credential manager, manual authentication and its associated problems can completely disappear. If such a communication channel existed, then the following operations would be possible:</p></div><div id="rfc.section.1.5.p.2"><ul><li><div><p>Account creation facilitated by the credential manager. The service could describe to the credential manager what authentication methods it supports, and what password restrictions it has. In response, a credential provider could (with or without user assistance) select an email address and generate a strong, unique password that is guaranteed to work.</p></div></li> <li><div><p>Automatic retrieval of existing credentials. At the appropriate moment, a service could request a credential, and have this automatically returned, or returned after some in-context user consent is solicited. This would be a marked improvement over the user manually finding and copying the credential, and minimizes the opportunity for the credential to be stolen in doing so.</p></div></li> <li><div><p>Maintenance of the credential manager store. When the service modifies an account, it can notify the credential manager of account changes. This information can be used to keep the credential store fresh.</p></div></li> <li><div><p>"Proof of access" to email addresses and phone numbers (as described in the <a href="#account-recovery-based-authentication" title="Account recovery based authentication">Section&nbsp;1.3</a> section above) could be directly solicited. While the credential manager may not have the authority to generate an ID token for a given email address, it could facilitate this process.</p></div><a class="self" href="#rfc.section.1.5.p.2">¶</a></li> </ul></div><div id="rfc.section.1.5.p.3"><p>OpenYOLO defines a protocol for this communication channel, a <em>discovery mechanism</em> for the user's credential managers, and a standard API for the client to use the above operations.</p></div></section></section><hr class="noprint"><section id="openyolo-concepts-and-definitions"><h2 id="rfc.section.2" class="np"><a href="#rfc.section.2">2.</a>&nbsp;<a href="#openyolo-concepts-and-definitions">OpenYOLO concepts and definitions</a></h2><div id="rfc.section.2.p.1"><p>Before providing a high level overview of the OpenYOLO operations, some terms that will be used throughout the discussion must be defined. Where data structures are described, this document uses <a href="https://developers.google.com/protocol-buffers">Protocol Buffer v3 messages</a> as the definition language. Where specific message instances are described, the <a href="https://developers.google.com/protocol-buffers/docs/proto3#json">Protocol Buffer v3 JSON encoding</a> is used.</p></div><section id="credentials"><h3 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a>&nbsp;<a href="#credentials">Credentials</a></h3><div id="rfc.section.2.1.p.1"><p>A <em>credential</em> is a set of properties that are used to help authenticate a user. Credentials can be <em>partial</em>, where they do not provide all necessary information for authentication.</p></div><div id="rfc.section.2.1.p.2" class="avoidbreakafter"><p>Credentials in OpenYOLO are composed of the following properties:</p></div><div id="rfc.section.2.1.p.3"><ul><li><div><p>An <em>authentication domain</em>, where the credential was originally saved. All stored credentials must have an associated authentication domain - there are no "ephemeral" credentials. Via an authentication domain <em>equivalence class</em>, a credential may be usable on multiple domains which are verifiably related to the declared domain. Due to this, the authentication domain on a credential may differ from that of the service which is requesting a credential.</p></div></li> <li><div><p>An <em>authentication method</em>, which describes the system used to verify the credential.</p></div></li> <li><div><p>An <em>identifier</em> which designates an account in the context of both the authentication domain and method. Typically, identifiers are email addresses, phone numbers, or some alphanumeric string. Identifiers are not always intended to be human readable.</p></div></li> <li><div><p>An optional <em>display name</em>, that assists the user in identifying and distinguishing credentials. Typically, the display name for a credential is the user's real name, or a chosen alias.</p></div></li> <li><div><p>An optional <em>display picture</em>, that fulfills a similar role to display name. Typically, the display picture is either a picture of the user, an avatar that they have chosen, or one they been assigned.</p></div></li> <li><div><p>An optional <em>password</em>, which is a human-readable secret used to authenticate with the service. Specifically, this field <em>must not</em> be used to store secrets that a user would not use directly, such as bearer tokens.</p></div></li> <li><div><p>An optional <em>ID token</em>, which provides "proof of access" to the identifier of the credential such as an email address or phone number.</p></div></li> <li><div><p>An optional additional set of non-standard properties. This provides the ability for credential providers to innovate within the constraints of the specification, with a view to later standardizing useful properties. Services <em>should not</em> rely upon additional properties, as their meaning is unlikely to be consistent across credential providers.</p></div><a class="self" href="#rfc.section.2.1.p.3">¶</a></li> </ul></div><div id="rfc.section.2.1.p.4" class="avoidbreakafter"><p>A credential is represented by the following protocol buffer message:</p></div><pre>
message Credential {
  // required
  string id = 1;

  // required
  AuthenticationDomain authDomain = 2;

  // required
  AuthenticationMethod authMethod = 3;

  string displayName = 4;
  string displayPictureUri = 5;
  string password = 6;
  string idToken = 7;
  map&lt;string, bytes&gt; additionalProps = 8;
}
</pre><section id="hints"><h4 id="rfc.section.2.1.1"><a href="#rfc.section.2.1.1">2.1.1.</a>&nbsp;<a href="#hints">Hints</a></h4><div id="rfc.section.2.1.1.p.1" class="avoidbreakafter"><p>Hints are a variant of credentials that include information for creating new accounts. They are represented by a separate protocol buffer message, to allow for future extension that may diverge from the definition of credentials. Hints are represented by the following protocol buffer message:</p></div><pre>
message Hint {
  // required
  string id = 1;

  // required
  AuthenticationMethod authMethod = 3;

  string displayName = 4;
  string displayPictureUri = 5;
  string generatedPassword = 6;
  string idToken = 7;
  map&lt;string, bytes&gt; additionalProps = 8;
}
</pre><div id="rfc.section.2.1.1.p.2" class="avoidbreakafter"><p>The two main differences from credentials are that:</p></div><div id="rfc.section.2.1.1.p.3"><ul><li><div><p>The authentication domain is not declared, as it is implicitly for use by the requesting service.</p></div></li> <li><div><p>The <span class="tt">password</span> field is renamed to <span class="tt">generatedPassword</span>, to express its intent more clearly.</p></div><a class="self" href="#rfc.section.2.1.1.p.3">¶</a></li> </ul></div></section></section><section id="credential-providers"><h3 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a>&nbsp;<a href="#credential-providers">Credential providers</a></h3><div id="rfc.section.2.2.p.1" class="avoidbreakafter"><p>A <em>credential provider</em> is a <em>credential manager</em> which implements the OpenYOLO protocol. Credential providers are typically one of the following:</p></div><div id="rfc.section.2.2.p.2"><ul><li><div><p>A dedicated service whose sole purpose is to store and recall credentials for the user.</p></div></li> <li><div><p>A web browser or custom input method, which provides credential management, but not as its primary focus.</p></div></li> <li><div><p>An operating system service, such as Smart Lock for Passwords on Android or Keychain on iOS.</p></div><a class="self" href="#rfc.section.2.2.p.2">¶</a></li> </ul></div><div id="rfc.section.2.2.p.3"><p>While any service can become a credential provider by implementing the OpenYOLO protocol, only services for which credential management is a defined and visible feature should become credential providers.</p></div><section id="known-unknown-and-preferred-providers"><h4 id="rfc.section.2.2.1"><a href="#rfc.section.2.2.1">2.2.1.</a>&nbsp;<a href="#known-unknown-and-preferred-providers">Known, unknown and preferred providers</a></h4><div id="rfc.section.2.2.1.p.1"><p>Given the sensitive nature of the data being exchanged by the OpenYOLO protocol, it will become an obvious target for attackers. A likely attack is for a suspicious service to implement the OpenYOLO protocol and attempt to register themselves as the user's credential provider. Distinguishing legitimate credential providers from malicious providers is therefore an important aspect of building trust in the protocol, for both service maintainers and users.</p></div><div id="rfc.section.2.2.1.p.2"><p>In order to achieve this, a <em>known provider</em> list will be maintained by the OpenID Foundation. A static snapshot of this list is included in the OpenYOLO API on each platform, and is automatically updated by the client library when necessary.</p></div><div id="rfc.section.2.2.1.p.3"><p>An <em>unknown</em> provider will still be usable - the intention of the known provider list is not to strictly whitelist providers, as this would stifle competition. However, additional user consent will be required upon every interaction with an unknown provider, to ensure the user is aware of the potential risks. Known providers will not have this restriction, and legitimate credential providers will be encouraged to register themselves with the OpenID Foundation to become known providers.</p></div><div id="rfc.section.2.2.1.p.4"><p>Additionally, where possible on each supported platform, the user <em>should</em> be able to specify their <em>preferred</em> credential provider. This preferred provider will be used exclusively for assisted sign-up and credential saving. For credential retrieval, additional providers <em>may</em> still be used.</p></div></section></section><section id="token-providers"><h3 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3.</a>&nbsp;<a href="#token-providers">Token providers</a></h3><div id="rfc.section.2.3.p.1"><p>A <em>token provider</em> is a service that is able to issue an authoritative "proof of access" ID token for an identifier. For example, Google is the token provider for all "gmail.com" email addresses, while Microsoft is the token provider for all "live.com" email addresses.</p></div><div id="rfc.section.2.3.p.2"><p>Token providers are identified by their canonical token-issuing domain - the domain on which the token endpoint that provides ID tokens is served on the web. In the case of Google, this is <span class="tt">https://accounts.google.com</span>.</p></div><div id="rfc.section.2.3.p.3"><p>Token providers can be authoritative for a large set of domains or numbers, and there is not often an easy way to determine in advance the token provider for a given domain. OpenYOLO does yet not attempt to solve this particular problem.</p></div></section><section id="authentication-domains"><h3 id="rfc.section.2.4"><a href="#rfc.section.2.4">2.4.</a>&nbsp;<a href="#authentication-domains">Authentication domains</a></h3><div id="rfc.section.2.4.p.1"><p>An <em>authentication domain</em> is defined to be a scope within which a credential is considered to be usable. Authentication domains are represented as absolute, hierarchical URIs of form <span class="tt">scheme://authority</span> - no path, query or fragment is permitted.</p></div><div id="rfc.section.2.4.p.2" class="avoidbreakafter"><p>In protocol buffer form, an authentication domain is represented by the following message:</p></div><pre>
message AuthenticationDomain {
  // required
  string uri = 1;
}
</pre><div id="rfc.section.2.4.p.3"><p>The URI is encapsulated in a message to allow for future extensibility of the concept of an authentication domain, without altering the structure of containing messages.</p></div><div id="rfc.section.2.4.p.4" class="avoidbreakafter"><p>Two forms of authentication domain are defined for OpenYOLO:</p></div><div id="rfc.section.2.4.p.5"><ul><li><div><p>Web authentication domains, which match the domain of the site and can have either a http or https scheme (e.g. <span class="tt">https://example.com</span> and <span class="tt">http://www.example.com</span> are valid web authentication domains). HTTPS is <em>strongly preferred</em> for use with OpenYOLO, but HTTP is also supported for testing and development purposes.</p></div></li> <li><div><p>Android authentication domains, of form <span class="tt">android://fingerprint@package</span> where <span class="tt">package</span> is the package name of an app (e.g. com.example.app), and <span class="tt">fingerprint</span> is a Base64, URL-safe encoding of the app's public key (provided by the <a href="https://developer.android.com/reference/android/content/pm/Signature.html">Signature</a> type in Android). The fingerprint string includes both the hash algorithm used, and the hash data, e.g. <span class="tt">sha512-7fmduHK...</span>. All OpenYOLO credential providers <em>must</em> support both <span class="tt">sha256</span> and <span class="tt">sha512</span> as hash algorithms for fingerprints, and <em>may</em> support any other hash algorithm that provides equivalent or better security than SHA-256.</p></div><a class="self" href="#rfc.section.2.4.p.5">¶</a></li> </ul></div><div id="rfc.section.2.4.p.6"><p>An <em>authentication system</em> which validates credentials may be represented by multiple distinct authentication domains. For example, a credential for <span class="tt">android://sha256-...@com.example.app</span> may be usable on <span class="tt">https://example.com</span> or <span class="tt">https://www.example.com</span>, when these three entities all use the same authentication system.</p></div><div id="rfc.section.2.4.p.7"><p>An authentication domain <em>equivalence class</em> defines the set of authentication domains associated with a given authentication system, and therefore the places where credentials can be used safely across domains. Such equivalence classes improve the usability of OpenYOLO, but must be carefully defined to avoid compromising the security of a user's credentials - equivalence classes <em>must</em> explicitly defined by the service and not assumed or heuristically constructed by the credential provider.</p></div><div id="rfc.section.2.4.p.8"><p>OpenYOLO recommends the use of the <a href="https://developers.google.com/digital-asset-links/">Digital Asset Links</a> as a standard mechanism to define authentication domain equivalence classes. Credential providers <em>should</em> use this information as part of defining the equivalence class over authentication domains. It is the responsibility of the credential provider to correctly construct and enforce the authentication domain equivalence class.</p></div></section><section id="authentication-methods"><h3 id="rfc.section.2.5"><a href="#rfc.section.2.5">2.5.</a>&nbsp;<a href="#authentication-methods">Authentication methods</a></h3><div id="rfc.section.2.5.p.1"><p>An <em>authentication method</em> is a mechanism by which a user credential can be verified, and is given a unique URI identifier. Any URI of form <span class="tt">scheme://authority</span> can be used to describe an authentication method. URIs of this form are used to allow for namespacing of custom authentication methods, by using a custom (private) scheme.</p></div><div id="rfc.section.2.5.p.2" class="avoidbreakafter"><p>In protocol buffer form, authentication methods are represented by the following message:</p></div><pre>
message AuthenticationMethod {
    // required
    string uri = 1;
}
</pre><div id="rfc.section.2.5.p.3"><p>The URI is encapsulated in a message to allow for future extensibility of the concept of an authentication method, without altering the structure of containing messages.</p></div><div id="rfc.section.2.5.p.4" class="avoidbreakafter"><p>OpenYOLO defines some standard URIs for the three most common types of authentication methods:</p></div><div id="rfc.section.2.5.p.5"><ul><li><div><p>Email identifier based authentication. This implies that the primary identifier of the account (from the user's perspective, at least) is their email address. Authentication requires a password or proof of access to the stated email address. The URI for this authentication method is standardized as <span class="tt">openyolo://email</span>.</p></div></li> <li><div><p>Phone number based authentication. This implies that the primary identifier for the account is a phone number, represented to OpenYOLO in <a href="https://www.itu.int/rec/T-REC-E.164/en">E.164</a> format. Authentication requires a password or proof of access to the stated phone number. The URI for this authentication method is standardized as <span class="tt">openyolo://phone</span>.</p></div></li> <li><div><p>User name and password based authentication. This implies that the primary identifier is some printable unicode string of characters, and that authentication requires a password. The URI for this authentication method is standardized as <span class="tt">openyolo://username</span>.</p></div><a class="self" href="#rfc.section.2.5.p.5">¶</a></li> </ul></div><div id="rfc.section.2.5.p.6"><p>Where a federated credential from an identity provider is desired, the canonical domain of that identity provider's authentication endpoints <em>should</em> be as the authentication method. OpenYOLO considers the <em>canonical</em> domain for an identity provider to be the domain on which that providers' sign in page is located. For example, the URI that should be used for Google Sign-in is <span class="tt">https://accounts.google.com</span>, while the URI that should be used for Facebook Sign-in accounts is <span class="tt">https://www.facebook.com</span>.</p></div><div id="rfc.section.2.5.p.7"><p>Use of consistent authentication method URIs for identity providers is strongly recommended, as this helps with hint retrieval - use of federated credentials on other services can be surfaced more easily when consistent authentication methods are used.</p></div></section><section id="password-specifications"><h3 id="rfc.section.2.6"><a href="#rfc.section.2.6">2.6.</a>&nbsp;<a href="#password-specifications">Password specifications</a></h3><div id="rfc.section.2.6.p.1"><p>services that support password based authentication often impose some restrictions on what is considered to be a valid and sufficiently secure password for the service. While the intentions behind these restrictions are often well-meaning, the inconsistency of these restrictions across different services is a constant source of frustration for both users and credential managers.</p></div><div id="rfc.section.2.6.p.2"><p>When credential managers attempt to generate passwords for a service, they are forced to generate using some "lowest common denominator" heuristic that produces passwords that are broadly supported. As even this can fail, they often must provide a way for the user to modify these generated passwords to fit the particular requirements of the service.</p></div><div id="rfc.section.2.6.p.3" class="avoidbreakafter"><p>A better approach would be for the service to declare its password restrictions in a format that can be consumed by credential managers. OpenYOLO defines a simple scheme for this, composed of the following pieces of information:</p></div><div id="rfc.section.2.6.p.4"><ul><li>The set of allowed characters in a password, which <em>must</em> be a subset of the ASCII printable character set.</li> <li>The minimum and maximum length of a password.</li> <li>Zero or more <em>required character sets</em>. A required character set must be a subset of the allowed character set, and specify the minimum number of characters from this set that must occur in the password. Where multiple required character sets are defined, the sets must be disjoint.<a class="self" href="#rfc.section.2.6.p.4">¶</a></li> </ul></div><div id="rfc.section.2.6.p.5" class="avoidbreakafter"><p>This is represented by the following protocol buffer message:</p></div><pre>
message PasswordSpecification {
  // required
  string allowed = 1;

  // required
  uint32 minSize = 2;

  // required
  uint32 maxSize = 3;

  repeated RequiredCharSet requiredSets = 4;
}

message RequiredCharSet {
  // required
  string chars = 1;

  // required
  uint32 count = 2;
}
</pre><div id="rfc.section.2.6.p.6" class="avoidbreakafter"><p>This allows the expression of most password restrictions. As an example, consider an authentication system that requires passwords be:</p></div><div id="rfc.section.2.6.p.7"><ul><li>Composed of any ASCII printable characters</li> <li>Be between 6 and 128 characters long</li> <li>Have at least one upper case character and one number.<a class="self" href="#rfc.section.2.6.p.7">¶</a></li> </ul></div><div id="rfc.section.2.6.p.8" class="avoidbreakafter"><p>This can be defined as follows (with the full contents of the allowed character set abbreviated):</p></div><pre>
{
  "allowed": "abcdef...",
  "minSize": 6,
  "maxSize": 128,
  "requiredSets": [
    {
      "chars": "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
      "count": 1
    },
    {
      "chars": "1234567890",
      "count": 1
    }
  ]
}
</pre><div id="rfc.section.2.6.p.9" class="avoidbreakafter"><p>Other common forms of credential, such as PIN numbers, can also be easily defined:</p></div><pre>
{
  "allowed": "0123456789",
  "minSize": 6,
  "maxSize": 6
}
</pre><div id="rfc.section.2.6.p.10" class="avoidbreakafter"><p>The default password specification used by OpenYOLO, where a provider does not explicitly specify an alternative, is:</p></div><pre>
{
  "allowed": "abcdefghijkmnopqrstxyzABCDEFGHJKLMNPQRSTXY3456789",
  "minSize": 12,
  "maxSize": 16,
  "requiredSets": [
    {
      "chars": "abcdefghijkmnopqrstxyz",
      "count": 1
    },
    {
      "chars": "ABCDEFGHJKLMNPQRSTXY",
      "count": 1
    },
    {
      "chars": "3456789",
      "count": 1
    }
  ]
}
</pre><div id="rfc.section.2.6.p.11"><p>This produces passwords of length 12 to 16 based on a "distinguishable" character set. Characters which look similar, such as l (Lima), I (India) and 1 (one) are omitted so as to avoid transcription errors should the user ever have to view and copy a generated password manually. It is designed to be broadly compatible and produce passwords with sufficient entropy to resist offline attacks, but it is still preferable for services to declare their own password restrictions.</p></div><div id="rfc.section.2.6.p.12" class="avoidbreakafter"><p>It is worth noting that this specification does not support the definition of the following types of password restriction:</p></div><div id="rfc.section.2.6.p.13"><ul><li>Positional restrictions, such as "the first character cannot be a number" or "the last two characters cannot be numbers".</li> <li>Semantic restrictions, such as "the password cannot contain an english word" or "the password cannot contain a year".<a class="self" href="#rfc.section.2.6.p.13">¶</a></li> </ul></div><div id="rfc.section.2.6.p.14"><p>Such restrictions are either indicative of some anti-pattern in the underlying credential store (e.g. the credential is stored in plain text), or are just too difficult to define a clear specification of expected behavior.</p></div></section><section id="client-versions"><h3 id="rfc.section.2.7"><a href="#rfc.section.2.7">2.7.</a>&nbsp;<a href="#client-versions">Client versions</a></h3><div id="rfc.section.2.7.p.1"><p>OpenYOLO client libraries will typically be compiled in to service implementations, and therefore cannot be changed without releasing a new version of the service that client devices must download. Bugs are inevitable, and where these bugs impact the security of the client it is important to have a mechanism to protect services from the exploitation of these bugs.</p></div><div id="rfc.section.2.7.p.2"><p>In order to facilitate this, requests sent from a service to a credential provider <em>should</em> carry a <em>client version</em> descriptor, which is typically compiled into the OpenYOLO client library they are using. This allows a credential provider to identify services which are using an exploitable version of the client library, and to reject requests from these clients.</p></div><div id="rfc.section.2.7.p.3" class="avoidbreakafter"><p>In OpenYOLO, a client version is composed of:</p></div><div id="rfc.section.2.7.p.4"><ul><li><div><p>A <em>vendor</em> string, which identifies the author of the client. For the official client libraries shipped by the OpenID Foundation, this will be "openid.net".</p></div></li> <li><div><p>A major, minor and patch version number. Each are non-negative numbers and typically represented in the human-readable form "X.Y.Z", and follow the general principles of <a href="http://semver.org/">Semantic Versioning</a>.</p></div><a class="self" href="#rfc.section.2.7.p.4">¶</a></li> </ul></div><div id="rfc.section.2.7.p.5"><p>In order to prevent trivial modification of the client version, it <em>should</em> be statically compiled in to the client library. There is no way to guarantee that the client version cannot be tampered with by an attacker, however; as such, client versions should be interpreted as an untrusted hint and used for the blacklisting of known problematic client versions only.</p></div><div id="rfc.section.2.7.p.6" class="avoidbreakafter"><p>In protocol buffer form, a client version is represented by the following message:</p></div><pre>
message ClientVersion {
  // required
  string vendor = 1;

  // required
  uint32 major = 3;

  // required
  uint32 minor = 4;

  // required
  uint32 patch = 5;
}
</pre></section></section><hr class="noprint"><section id="operations"><h2 id="rfc.section.3" class="np"><a href="#rfc.section.3">3.</a>&nbsp;<a href="#operations">Operations</a></h2><div id="rfc.section.3.p.1" class="avoidbreakafter"><p>OpenYOLO defines four core operations:</p></div><div id="rfc.section.3.p.2"><ul><li><em>hint retrieval</em>: Provides basic account information to help create a new account.</li> <li><em>credential retrieval</em>: Provides access to an existing stored credential for the requesting service.</li> <li><em>credential save</em>: Allows a service to store or update a credential in a credential provider.</li> <li><em>credential delete</em>: Allows a service to delete a credential which is no longer valid.<a class="self" href="#rfc.section.3.p.2">¶</a></li> </ul></div><div id="rfc.section.3.p.3"><p>These are described in more detail in the following sections.</p></div><section id="hint-retrieval"><h3 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a>&nbsp;<a href="#hint-retrieval">Hint retrieval</a></h3><div id="rfc.section.3.1.p.1" class="avoidbreakafter"><p>When an service wants to create a new account for the user, they typically need the following core pieces of information:</p></div><div id="rfc.section.3.1.p.2"><ul><li><div><p>The <em>authentication method</em> that the user prefers to use, drawn from the set that the service supports. For instance, a service may allow a user to create an account with a phone number, Google Sign-in or Facebook Sign-in. If a non-federated authentication method is used, a <em>generated password</em> that conforms to the service's password restrictions is desirable.</p></div></li> <li><div><p>A unique <em>identifier</em> for the account, which is typically an email address, or phone number that would also be used for account recovery. For many services, proof of access to this identifier is crucial, and so an ID token is also desired to avoid an out-of-context verification.</p></div></li> <li><div><p>A <em>display name</em> and <em>profile picture</em> for the user, in order to personalize the service. Where it is possible for a user to have multiple accounts with the service, the</p></div><a class="self" href="#rfc.section.3.1.p.2">¶</a></li> </ul></div><div id="rfc.section.3.1.p.3"><p>The OpenYOLO <em>hint retrieval</em> operation allows a service to request this information from the credential provider. In response, the credential provider is expected to present a choice of the user's commonly-used identifiers or federated credentials, enabling a "single tap" account creation experience. After selection, the provider should return a Credential object representing the user's selection, optionally including a generated password or ID token if applicable. A hint <em>must not</em> be returned automatically by a credential provider - user interaction is strictly required before any personally identifying information is returned.</p></div><div id="rfc.section.3.1.p.4"><p>Where a proof of access ID token is desired, a service must declare the <em>token providers</em> that is supports. Additionally, for each supported token provider, a <em>client ID</em> may be required. This is typically a value generated by the token provider during registration as an OAuth2 client. Finally, a <em>nonce</em> can be provided that will be included in any generated ID token, as a protection against replay attacks. Non-standard properties specific to each token provider may be specified via an additional properties map.</p></div><section id="hint-request-message"><h4 id="rfc.section.3.1.1"><a href="#rfc.section.3.1.1">3.1.1.</a>&nbsp;<a href="#hint-request-message">Hint request message</a></h4><div id="rfc.section.3.1.1.p.1" class="avoidbreakafter"><p>A hint retrieval request is represented by the following protocol buffer message:</p></div><pre>
message HintRetrieveRequest {
    ClientVersion version = 1;

    // at least one authMethod required
    repeated AuthenticationMethod authMethods = 2;

    PasswordSpecification passwordSpec = 3;
    map&lt;string, TokenRequestInfo&gt; supportedTokenProviders = 4;
    map&lt;string, bytes&gt; additionalProps = 5;
}

message TokenRequestInfo {
    string clientId = 1;
    string nonce = 2;
    map&lt;string, bytes&gt; additionalProps = 3;
}
</pre><div id="rfc.section.3.1.1.p.2" class="avoidbreakafter"><p>A simple hint request (omitting the client version) would then look like the following:</p></div><pre>
{
  "authMethods": [
    "openyolo://email",
    "https://accounts.google.com",
    "https://www.facebook.com"
  ]
}
</pre><div id="rfc.section.3.1.1.p.3"><p>This indicates that the service supports email and password based authentication, Google Sign-in and Facebook Sign-in. The service has not declared a password specification, therefore the OpenYOLO default specification should be used by the credential provider if necessary. No supported token providers have been specified, therefore no ID token is desired.</p></div><div id="rfc.section.3.1.1.p.4" class="avoidbreakafter"><p>A more complex request, with a custom password specification and two supported token provider could look like:</p></div><pre>
{
  "authMethods": [
    "openyolo://email"
  ],
  "passwordSpec": {
    "allowed": "0123456789",
    "minSize": 6,
    "maxSize": 6
  },
  "supportedTokenProviders": {
    "https://accounts.google.com": {
      "clientId": "CLIENT.apps.googleusercontent.com",
      "nonce": "asdf123"
    },
    "https://auth.example.com": {
      "clientId": "11451",
      "nonce": "asdf123"
    }
  }
}
</pre></section><section id="hint-response-message"><h4 id="rfc.section.3.1.2"><a href="#rfc.section.3.1.2">3.1.2.</a>&nbsp;<a href="#hint-response-message">Hint response message</a></h4><div id="rfc.section.3.1.2.p.1" class="avoidbreakafter"><p>A hint retrieval request is represented by the following protocol buffer message:</p></div><pre>
message HintRetrieveResult {
  // required
  HintRetrieveResultCode resultCode = 1;

  Hint hint = 2;
  map&lt;string, bytes&gt; additionalProps = 3;
}

enum HintRetrieveResultCode {
  HINT_RETRIEVE_SUCCESS = 0;
  HINT_RETRIEVE_REJECTED = 1;
  HINT_RETRIEVE_REJECTED_BY_USER = 2;
}
</pre><div id="rfc.section.3.1.2.p.2" class="avoidbreakafter"><p>An email and password credential hint that could be returned for a requesting app "com.example.app" could be:</p></div><pre>
{
  "id": "jblack@example.com",
  "authDomain": "android://sha256-...@com.example.app",
  "authMethod": "openyolo://email",
  "displayName": "Jack Black",
  "displayPictureUri": "https://www.robohash.org/dcd65581?set=3",
  "password": "YjW5Zvn3Fc7fY",
  "idToken":
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpX
      VCJ9.eyJzdWIiOiJqZG9lQGdtYWlsLmNv
      bSIsImF1ZCI6Imh0dHBzOi8vbG9naW4uZ
      XhhbXBsZS5jb20iLCJpc3MiOiJodHRwcz
      ovL2F1dGguZXhhbXBsZS5jb20iLCJuYW1
      lIjoiSmFuZSBEb2UifQ.CibuoaNMO-2pR
      QjWUbJMpMLWjKB34AMWCR4pIWD5tnE"
}
</pre><div id="rfc.section.3.1.2.p.3" class="avoidbreakafter"><p>Alternatively, a federated credential hint for Google Sign-in returned to a requesting site <span class="tt">https://login.example.com</span> may look like:</p></div><pre>
{
  "id": "jdoe@gmail.com",
  "authDomain": "https://login.example.com",
  "authMethod": "https://accounts.google.com",
  "displayName": "John Doe"
}
</pre></section><section id="example-hint-retrieval-scenario"><h4 id="rfc.section.3.1.3"><a href="#rfc.section.3.1.3">3.1.3.</a>&nbsp;<a href="#example-hint-retrieval-scenario">Example hint retrieval scenario</a></h4><div id="rfc.section.3.1.3.p.1"><p>Jane Doe is visiting the travel site <span class="tt">https://adventures.example.com</span> for the first time. Upon first page load, the site attempts to retrieve an existing credential using OpenYOLO, but nothing is saved so it does not interrupt Jane's flow further at this point.</p></div><div id="rfc.section.3.1.3.p.2" class="avoidbreakafter"><p>After browsing a few travel packages, Jane notices a button with label "save for later", and decides to press it. The service navigates to an account creation screen, explaining that an account must be created to save the package. At this point, the service sends a hint retrieval request, and a hint selector dialog is presented:</p></div><pre>
+------------------------------------+
|                              +---+ |
| Continue With:               | X | |
|                              +---+ |
| +--------------------------------+ |
|                                    |
|  +---+ Jane Doe                    |
|  | O |                             |
|  |/_\| jdoe@gmail.com              |
|  +---+                             |
|        (with generated password)   |
|                                    |
| +--------------------------------+ |
|                                    |
|  +---+ John Doe                    |
|  | O |                             |
|  |/_\| john@example.com            |
|  +---+                             |
|        (with generated password)   |
|                                    |
| +--------------------------------+ |
|                                    |
|  +---+ Jill Doe                    |
|  | O |                             |
+--+---+-----------------------------+
</pre><div id="rfc.section.3.1.3.p.3"><p>Jane selects her most commonly used email address; a password is generated and a credential returned to the service, and the provider is able to produce an ID token for the selected email address.</p></div><div id="rfc.section.3.1.3.p.4"><p>The service utilizes the returned hint to bootstrap the new account, and after successfully creating the account requests that the credential provider save the credential. As the credential has not been modified by the site from the details in the returned hint, it saves the credential automatically.</p></div><div id="rfc.section.3.1.3.p.5"><p>From Jane's perspective, this all happens from a single click on an account in a presented dialog. She is now signed in, and the travel package she selected is now saved to her account so she can return to it later.</p></div></section></section><section id="credential-retrieval"><h3 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a>&nbsp;<a href="#credential-retrieval">Credential retrieval</a></h3><div id="rfc.section.3.2.p.1"><p>Where an existing credential is known for a service, it is often beneficial to the service and the user for that credential to be retrieved and used for authentication as early as possible. This allows the service to be appropriately personalized to the user, such as providing shopping recommendations based on past purchases. This should, of course, respect the user's preferences, as there are many legitimate use cases where a user may wish to browse a service in a signed-out state even when a saved credential is known.</p></div><section id="credential-request-message"><h4 id="rfc.section.3.2.1"><a href="#rfc.section.3.2.1">3.2.1.</a>&nbsp;<a href="#credential-request-message">Credential request message</a></h4><div id="rfc.section.3.2.1.p.1" class="avoidbreakafter"><p>A credential retrieval request is represented by the following protocol buffer message:</p></div><pre>
message CredentialRetrieveRequest {
    // required
    ClientVersion version = 1;

    // at least one authMethod required
    repeated AuthenticationMethod authMethods = 2;

    map&lt;string, TokenRequestInfo&gt; supportedTokenProviders = 3;
    map&lt;string, bytes&gt; additionalProps = 4;
}
</pre><div id="rfc.section.3.2.1.p.2"><p>The service lists the authentication methods that it supports, which are used to filter the set of credentials that are stored by the credential provider. Similar to hint requests, the service can also specify its supported token providers - the return of a valid ID token can provide an additional signal to the service that this login attempt is legitimate.</p></div><div id="rfc.section.3.2.1.p.3" class="avoidbreakafter"><p>In response to a credential request, the credential provider can either:</p></div><div id="rfc.section.3.2.1.p.4"><ul><li>directly return a credential for automatic sign-in</li> <li>Show a credential picker to the user</li> <li>Return nothing if no matching credentials are available<a class="self" href="#rfc.section.3.2.1.p.4">¶</a></li> </ul></div><div id="rfc.section.3.2.1.p.5"><p>Automatically returning a credential is optional, and if it is a facility provided by the credential provider, <em>must</em> be something that the user can disable. A credential should only be returned by a provider if it believes that the credential is a valid, existing credential for the requesting service.</p></div><div id="rfc.section.3.2.1.p.6"><p>Credential retrieval implementations <em>must not</em> attempt to generate new credentials during this flow - this is the responsibility of the hint retrieval operation, and it is expected that the operations will be used at different times by the service.</p></div><div id="rfc.section.3.2.1.p.7" class="avoidbreakafter"><p>An example credential retrieval request for the site <span class="tt">https://www.example.com</span> could look like:</p></div><pre>
{
  "authMethods": [
    "openyolo://phone",
    "https://www.facebook.com"
  ]
}
</pre></section><section id="credential-response-message"><h4 id="rfc.section.3.2.2"><a href="#rfc.section.3.2.2">3.2.2.</a>&nbsp;<a href="#credential-response-message">Credential response message</a></h4><div id="rfc.section.3.2.2.p.1" class="avoidbreakafter"><p>The response to a credential request is represented by the following protocol buffer message:</p></div><pre>
message CredentialRetrieveResult {
  // required
  CredentialRetrieveResultCode resultCode = 1;

  Credential credential = 2;
  map&lt;string, bytes&gt; additionalProps = 3;
}

enum CredentialRetrieveResultCode {
    CREDENTIAL_RETRIEVE_SUCCESS = 0;
    CREDENTIAL_RETRIEVE_REJECTED = 1;
    CREDENTIAL_RETRIEVE_REJECTED_BY_USER =2;
}
</pre><div id="rfc.section.3.2.2.p.2" class="avoidbreakafter"><p>An example response could therefore look like:</p></div><pre>
{
  "resultCode": "CREDENTIAL_RETRIEVE_SUCCESS",
  "credential": {
    "id": "jdoe",
    "authDomain": "https://login.example.com",
    "authMethod": "https://www.facebook.com"
  }
}
</pre><div id="rfc.section.3.2.2.p.3" class="avoidbreakafter"><p>Or, if the user was presented a list of credentials and did not select one:</p></div><pre>
{
  "resultCode": "CREDENTIAL_RETRIEVE_REJECTED_BY_USER"
}
</pre></section><section id="example-credential-retrieval-scenario"><h4 id="rfc.section.3.2.3"><a href="#rfc.section.3.2.3">3.2.3.</a>&nbsp;<a href="#example-credential-retrieval-scenario">Example credential retrieval scenario</a></h4><div id="rfc.section.3.2.3.p.1"><p>Jane has just bought a new phone and has just installed the "TechNews" app. When she opens the app, it immediately sends a credential retrieval request for email, Google and Facebook stored credentials. Jane frequently used TechNews on her old phone and had saved his email address and password with her credential provider. Her credential provider receives the request, and automatically returns the saved credential to the TechNews app and displays a notification that it has done so. The TechNews app uses the credential to sign in, and shows Jane her personalized feed of news.</p></div></section></section><section id="credential-saving"><h3 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a>&nbsp;<a href="#credential-saving">Credential saving</a></h3><div id="rfc.section.3.3.p.1"><p>Once a user has created an account or successfully signed in using an existing account, it is beneficial to them for this credential to be saved to their credential provider. This ensures that when the user changes device, or their session is invalidated, re-authentication is simplified through the use of the credential retrieval operation.</p></div><div id="rfc.section.3.3.p.2"><p>In the case where a service saves a credential that is already known, this is still a useful signal to the credential provider that the saved data is accurate. Where discrepancies are detected, such as a change in password, this provides an opportunity to confirm and update the saved data. Credential providers <em>may</em> allow automatic saving of credentials, but it is recommended to seek explicit confirmation from the user where the credential data is new or sensitive (i.e. contains a previously unseen identifier or password).</p></div><div id="rfc.section.3.3.p.3" class="avoidbreakafter"><p>How this confirmation is solicited from the user is outside the scope of this specification; the reference implementation uses the following confirmation dialog style design:</p></div><pre>
+------------------------------------+
|                                    |
| Save your password for ExampleApp  |
|         to ExampleProvider?        |
|                                    |
|    +----+ +--------------------+   |
|    | OK | | Never for this app |   |
|    +----+ +--------------------+   |
|                                    |
+------------------------------------+
</pre><section id="save-request-message"><h4 id="rfc.section.3.3.1"><a href="#rfc.section.3.3.1">3.3.1.</a>&nbsp;<a href="#save-request-message">Save request message</a></h4><div id="rfc.section.3.3.1.p.1" class="avoidbreakafter"><p>A save credential request is represented by the following protocol buffer message:</p></div><div id="rfc.section.3.3.1.p.2"><p>message CredentialSaveRequest { ClientVersion clientVersion = 1;</p></div><pre>
// required
Credential credential = 2;

map&lt;string, bytes&gt; additionalProps = 3;
</pre><div id="rfc.section.3.3.1.p.3"><p>}</p></div></section><section id="save-response-message"><h4 id="rfc.section.3.3.2"><a href="#rfc.section.3.3.2">3.3.2.</a>&nbsp;<a href="#save-response-message">Save response message</a></h4><pre>
message CredentialSaveResult {
    // required
    CredentialSaveResultCode resultCode = 1;

    map&lt;string, bytes&gt; additionalProps = 2;
}

enum CredentialSaveResultCode {
    CREDENTIAL_SAVE_SUCCESS = 0;
    CREDENTIAL_SAVE_REJECTED = 1;
    CREDENTIAL_SAVE_REJECTED_BY_USER = 2;
}
</pre></section><section id="example-credential-save-scenario"><h4 id="rfc.section.3.3.3"><a href="#rfc.section.3.3.3">3.3.3.</a>&nbsp;<a href="#example-credential-save-scenario">Example credential save scenario</a></h4></section></section><section id="credential-deletion"><h3 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4.</a>&nbsp;<a href="#credential-deletion">Credential deletion</a></h3><div id="rfc.section.3.4.p.1"><p>Stale credentials stored in a credential provider are a source of frustration for users. Stale credentials are particularly common in browsers that rely on heuristics to detect password changes and update saved credentials.</p></div><div id="rfc.section.3.4.p.2"><p>When a credential is stale, it is useless only serves as a barrier to authentication. In most cases, the user will be forced to perform a tedious account recovery process. In order to provide services a way to flag stale credentials to a provider, a credential deletion operation is defined.</p></div><div id="rfc.section.3.4.p.3"><p>Credential providers <em>should not</em> allow automatic deletion of credentials, as this would allow misbehaving services to delete valid credentials. Financial institutions are notorious for these kinds of user-hostile policies, and may attempt to delete valid credentials as a misguided way to "protect" the user. As such, credential deletion <em>should</em> require explicit user confirmation. Where this is done legitimately, such as after a retrieved credential is discovered to be invalid or a user deletes their account, the request for confirmation should not be surprising to the user.</p></div><div id="rfc.section.3.4.p.4" class="avoidbreakafter"><p>How user confirmation for deleting a credential is solicited is out of the scope of this specification; the reference implementation uses a confirmation dialog style design:</p></div><pre>
+--------------------------------------+
|                                      |
|     Delete password for account      |
| jdoe@gmail.com from ExampleProvider? |
|                                      |
|       +------+   +-----------+       |
|       |  OK  |   | No thanks |       |
|       +------+   +-----------+       |
|                                      |
+--------------------------------------+
</pre><section id="delete-request-message"><h4 id="rfc.section.3.4.1"><a href="#rfc.section.3.4.1">3.4.1.</a>&nbsp;<a href="#delete-request-message">Delete request message</a></h4><pre>
message CredentialDeleteRequest {
    ClientVersion clientVersion = 1;

    // required
    Credential credential = 2;

    map&lt;string, bytes&gt; additionalProps = 3;
}
</pre></section><section id="delete-response-message"><h4 id="rfc.section.3.4.2"><a href="#rfc.section.3.4.2">3.4.2.</a>&nbsp;<a href="#delete-response-message">Delete response message</a></h4><pre>
message CredentialDeleteResult {
    // required
    CredentialDeleteResultCode resultCode = 1;

    map&lt;string, bytes&gt; additionalProps = 2;
}

enum CredentialDeleteResultCode {
    CREDENTIAL_DELETE_SUCCESS = 0;
    CREDENTIAL_DELETE_REJECTED = 1;
    CREDENTIAL_DELETE_REJECTED_BY_USER = 2;
}
</pre></section><section id="example-credential-deletion-scenario"><h4 id="rfc.section.3.4.3"><a href="#rfc.section.3.4.3">3.4.3.</a>&nbsp;<a href="#example-credential-deletion-scenario">Example credential deletion scenario</a></h4><div id="rfc.section.3.4.3.p.1"><p>TODO</p></div></section></section></section><hr class="noprint"><section id="openyolo-on-android"><h2 id="rfc.section.4" class="np"><a href="#rfc.section.4">4.</a>&nbsp;<a href="#openyolo-on-android">OpenYOLO on Android</a></h2><div id="rfc.section.4.p.1"><p>The OpenYOLO protocol on Android is designed to run on any Android API 15+ device, including devices which do not have Google Play Services available. OpenYOLO operation requests and responses are handled using core communication primitives on Android: broadcast messages and activity intents.</p></div><div id="rfc.section.4.p.2"><p>Devices with Google Play Services already have a credential provider available, in the form of Google's Smart Lock for Passwords. In addition to this, the user may have installed an additional credential manager. In such a situation is it common for a user to have credentials split across these two providers; as such, it is particularly important on Android to be able to query multiple providers. To service this goal, this specification also defines the Background Broadcast Query (BBQ) protocol, which is used to perform the initial step of requesting credentials from installed providers.</p></div><div id="rfc.section.4.p.3"><p>Hint and save requests are simpler, as there is no need to interact with multiple credential providers. For these operations, an Intent is simply constructed for a credential provider, with the hint or save request carried as a binary protocol buffer via an intent extra. This does, however, leave the problem of deciding <em>which</em> credential provider these requests should be sent to.</p></div><section id="discovering-installed-providers"><h3 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a>&nbsp;<a href="#discovering-installed-providers">Discovering installed providers</a></h3><div id="rfc.section.4.1.p.1" class="avoidbreakafter"><p>The set of installed credential providers on an Android device can be be determined using the system <a href="https://developer.android.com/reference/android/content/pm/PackageManager.html">PackageManager</a> query interface. OpenYOLO providers must define an activity for hint retrieval, which must be listed in the provider app manifest with the following intent filter:</p></div><pre>
&lt;intent-filter&gt;
    &lt;action android:name="org.openyolo.hint"/&gt;
    &lt;category android:name="org.openyolo" /&gt;
&lt;/intent-filter&gt;
</pre><div id="rfc.section.4.1.p.2" class="avoidbreakafter"><p>Based on this, all installed credential providers can be located through the following package manager query:</p></div><pre>
Intent hintIntent = new Intent("org.openyolo.hint");
saveIntent.addCategory("org.openyolo");

List&lt;ResolveInfo&gt; resolvedProviders =
    mApplicationContext.getPackageManager()
        .queryIntentActivities(saveIntent, 0);
</pre></section><section id="preferred-credential-providers-on-android"><h3 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a>&nbsp;<a href="#preferred-credential-providers-on-android">Preferred credential providers on Android</a></h3><div id="rfc.section.4.2.p.1" class="avoidbreakafter"><p>In the future, Android or Google Play Services may directly store a user's preferred credential provider. However, in the meantime, a simple heuristic is specified that will determine the user's preferred credential provider in most cases:</p></div><div id="rfc.section.4.2.p.2"><ol><li>Enumerate all the credential providers installed on the device. If there are any <em>unknown providers</em>, then there is no preferred provider.</li> <li>If there are no <em>known providers</em>, there is no preferred provider.</li> <li>If there is exactly one installed provider, and it is known, this is the preferred provider.</li> <li>If there are exactly two installed providers, both are known, and one of them is Google's Smart Lock for passwords, the preferred provider is the non-Google provider.</li> <li>If there are three or more known providers, there is no preferred provider.<a class="self" href="#rfc.section.4.2.p.2">¶</a></li> </ol></div><div id="rfc.section.4.2.p.3"><p>Where there is no preferred provider, the user must explicitly select the provider they wish to use for each hint and credential storage operation. This minimizes the risk of "security surprise", where the user finds themselves interacting with an unexpected credential provider.</p></div><div id="rfc.section.4.2.p.4"><p>The heuristic takes into account that Google's Smart Lock for Passwords will be installed by default on the vast majority of Android devices, and that most users will not have make a conscious effort to use this credential provider. When a second credential provider is manually installed, it is likely that the user's intent is to user that provider rather than the "system default" of Smart Lock for Passwords.</p></div></section><section id="background-broadcast-query-protocol-bbq"><h3 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a>&nbsp;<a href="#background-broadcast-query-protocol-bbq">Background broadcast query protocol (BBQ)</a></h3><div id="rfc.section.4.3.p.1"><p>BBQ is a protocol designed to allow an Android app to request data from multiple <em>data providers</em> on the device, in parallel. Requests and responses are sent as targeted broadcast messages, with protocol buffers used to encode the request and response data. The use of broadcast messages allows implementations to be fully asynchronous, and protocol buffers allow messages to be compact and efficient, while avoiding common issues with custom Parcelable types.</p></div><section id="structure-of-a-request"><h4 id="rfc.section.4.3.1"><a href="#rfc.section.4.3.1">4.3.1.</a>&nbsp;<a href="#structure-of-a-request">Structure of a request</a></h4><div id="rfc.section.4.3.1.p.1" class="avoidbreakafter"><p>A broadcast query has the following mandatory properties:</p></div><div id="rfc.section.4.3.1.p.2"><ul><li>The data type being requested, described with <a href="https://en.wikipedia.org/wiki/Reverse_domain_name_notation">reverse domain name notation</a>, as is typically used for package names and intent actions in Android. For example, <span class="tt">org.openyolo.credential</span>.</li> <li>The package name of the requesting app, e.g. <span class="tt">com.example.app</span>.</li> <li>A randomly generated, 64-bit request ID. This is used to distinguish the request from other requests with the same data type that may not have been fully resolved.</li> <li>A randomly generated, 64-bit response ID. A separate response ID is generated for each expected responder, allowing responders to be distinguished and their identity to be recovered from the mapping of response ID to package name that is created prior to sending the request.</li> <li>A description of the cryptographic scheme used for the exchange: <div><ul><li>A string that uniquely identifies the scheme.</li> <li>A set of key-value pairs carrying scheme-specific parameters.</li> </ul></div><a class="self" href="#rfc.section.4.3.1.p.2">¶</a></li> </ul></div><div id="rfc.section.4.3.1.p.3"><p>An additional data-type specific message can be carried in the request if necessary, in the form of a byte-array (typically an encoded protocol buffer). Additional parameters can also be encoded into the message as key-value pairs, allowing for extension of the protocol itself.</p></div><div id="rfc.section.4.3.1.p.4"><p>The request is encoded using a <a href="https://developers.google.com/protocol-buffers">protocol buffer (v2) message</a>. Following the current guidance for protocol buffer message definitions, all fields are marked <span class="tt">optional</span> or <span class="tt">repeated</span> to provide flexibility in changing this specification in future. Fields currently considered to be required are marked as such with a comment.</p></div><pre>
message BroadcastQuery {
  // required fields:
  string dataType = 1;
  string requestingApp = 2;
  sfixed64 requestId = 3;
  sfixed64 responseId = 4;

  // optional fields:
  bytes queryMessage = 5;
  map&lt;string, bytes&gt; additionalProps = 6;
}
</pre></section><section id="dispatching-a-request"><h4 id="rfc.section.4.3.2"><a href="#rfc.section.4.3.2">4.3.2.</a>&nbsp;<a href="#dispatching-a-request">Dispatching a request</a></h4><div id="rfc.section.4.3.2.p.1" class="avoidbreakafter"><p>A request is dispatched as one or more targeted broadcast intents. First, the requester uses the Android <a href="https://developer.android.com/reference/android/content/pm/PackageManager.html">PackageManager</a> API to determine the set of apps which can provide data of the required type:</p></div><pre>
Intent intent = new Intent(dataType);
intent.addCategory(BBQ_CATEGORY);
List&lt;ResolveInfo&gt; responderInfos =
    packageManager.queryBroadcastReceivers(intent, 0);
</pre><div id="rfc.section.4.3.2.p.2" class="avoidbreakafter"><p>A separate request is created for each potential responder, with a unique response ID, and sent as a targeted broadcast:</p></div><pre>
BroadcastQuery query = BroadcastQuery.newBuilder()
    /* ... */
    .setResponseId(idForResponder.get(responder))
    .build();
Intent bbqIntent = new Intent(dataType);
bbqIntent.setPackage(responder);
bbqIntent.setExtra(EXTRA_QUERY_MESSAGE, query.encode());
context.sendBroadcast(bbqIntent);
</pre></section><section id="structure-of-a-response"><h4 id="rfc.section.4.3.3"><a href="#rfc.section.4.3.3">4.3.3.</a>&nbsp;<a href="#structure-of-a-response">Structure of a response</a></h4><div id="rfc.section.4.3.3.p.1" class="avoidbreakafter"><p>A broadcast query response has the following mandatory properties:</p></div><div id="rfc.section.4.3.3.p.2"><ul><li>The 64-bit request ID that the response is associated with, copied from the request.</li> <li>The 64-bit response ID unique to this response, copied from the request.<a class="self" href="#rfc.section.4.3.3.p.2">¶</a></li> </ul></div><div id="rfc.section.4.3.3.p.3"><p>Query responses are also represented as a V2 protocol buffer messages. The response copies the request and response IDs from the request message, and may include a data-type specific response message, if necessary. The absence of a data-type specific response message is generally interpreted to mean that the provider is unable to service the request.</p></div><div id="rfc.section.4.3.3.p.4" class="avoidbreakafter"><p>The structure of the query response message is therefore as follows:</p></div><pre>
message BroadcastQueryResponse {
  // required fields:
  sfixed64 requestId = 1;
  sfixed64 responseId = 2;

  // optional fields:
  bytes responseMessage = 3;
  map&lt;string, bytes&gt; additionalProps = 4;
}
</pre></section><section id="receiving-a-response"><h4 id="rfc.section.4.3.4"><a href="#rfc.section.4.3.4">4.3.4.</a>&nbsp;<a href="#receiving-a-response">Receiving a response</a></h4><div id="rfc.section.4.3.4.p.1"><p>Responses are sent back to the requester in the form of targeted broadcasts. The requester dynamically registers a broadcast receiver to capture responses. The <em>ACTION</em> for the response is the requested data type with the request ID concatenated in zero-padded hex form, e.g. "org.openyolo.credential:000000000000CAFE" where "org.openyolo.credential" is the requested data type and "000000000000CAFE" is the request ID (51966 in decimal).</p></div><pre>
IntentFilter filter = new IntentFilter();
filter.addAction(encodeAction(dataType, requestId));
filter.addCategory(BBQ_CATEGORY);
context.registerReceiver(new BroadcastReciever() { ... }, filter);
</pre><div id="rfc.section.4.3.4.p.2"><p>In order to avoid waiting indefinitely for responses from faulty receivers, a timeout should be used, after which absent responses should be treated as though the provider was unable to service the request (equivalent to responding with no data-type specific message payload).</p></div></section><section id="security-on-rooted-devices"><h4 id="rfc.section.4.3.5"><a href="#rfc.section.4.3.5">4.3.5.</a>&nbsp;<a href="#security-on-rooted-devices">Security on rooted devices</a></h4><div id="rfc.section.4.3.5.p.1"><p>The BBQ protocol relies on the integrity of the Android broadcast system (and the <span class="tt">setPackage</span> mechanism for targeted broadcast messages in particular) to guarantee the privacy of the messages sent between a requester and a provider. On a rooted device, it is potentially possible for a malicious app or system service with root access to read these messages, and expose plain-text passwords.</p></div><div id="rfc.section.4.3.5.p.2"><p>Cryptography provides no additional protection. If an attacker can read the private messages sent via the broadcast system, this will typically imply they have access to the memory location of the buffers. If ephemeral public-private key pairs are used, which don't authenticate either party, a man-in-the-middle attack is possible.</p></div><div id="rfc.section.4.3.5.p.3" class="avoidbreakafter"><p>There is no trusted third party which can sign keys to prove they are associated to a particular app:</p></div><div id="rfc.section.4.3.5.p.4"><ul><li><div><p>Key pairs cannot be distributed with the app, as they could be easily extracted from the application in advance, or on-demand with root access on the device.</p></div></li> <li><div><p>Keys cannot be dynamically signed by a trusted entity on the device (such as the platform itself, or Google Play Services) as these exchanges would also be susceptible to attack by anything with root access.</p></div><a class="self" href="#rfc.section.4.3.5.p.4">¶</a></li> </ul></div><div id="rfc.section.4.3.5.p.5" class="avoidbreakafter"><p>As such, we strongly recommend that password manager apps disable the OpenYOLO protocol on rooted devices, if they are able to detect this. The option could be given to the user to re-enable the feature, with a warning as to the security risks of doing this. Generally, rooted devices are very risky to a user's security, so warning users of this fact prior to even allowing a password manager to be configured is also advisable, as the following attacks are also possible:</p></div><div id="rfc.section.4.3.5.p.6"><ul><li>Directly reading keys and passwords from the memory space of the password manager or app</li> <li>Scraping the contents of EditText instances for passwords</li> <li>Key-logging the user</li> <li>Injecting code into the process space of the password manager or app<a class="self" href="#rfc.section.4.3.5.p.6">¶</a></li> </ul></div><div id="rfc.section.4.3.5.p.7"><p>The authors of this specification have no evidence that the kernel modifications required to break this protocol exist on real devices, but they are certainly feasible. As such, all rooted devices should be treated with suspicion when using the BBQ protocol to transport security- or privacy-sensitive data.</p></div></section></section><section id="retrieving-hints"><h3 id="rfc.section.4.4"><a href="#rfc.section.4.4">4.4.</a>&nbsp;<a href="#retrieving-hints">Retrieving Hints</a></h3><div id="rfc.section.4.4.p.1"><p>If no existing credentials can be retrieved from a credential provider, then OpenYOLO provides a fall-back mechanism that can be used to help in creating a new account. This mechanism will typically allow a new user account to be created without the need to manually enter any information.</p></div><div id="rfc.section.4.4.p.2"><p>First, the app must provide a descriptor of the types of credentials that it can support. This is done by providing a list of one or more supported authentication methods. If password authentication is supported, then a <em>password specification</em> can optionally be provided that describes the set of passwords that the app supports.</p></div><div id="rfc.section.4.4.p.3"><p>This descriptor can then be sent to a credential provider using the OpenYOLO API in order to derive a credential hint. If a default credential provider can be determined by the OpenYOLO API, then it will construct an intent to send the descriptor to this provider and return it for the app to dispatch when ready. Similarly, if only one credential provider is available on the device and it is a "known" provider, then an intent to directly interact with that provider will be constructed and returned. See <a href="protecting-users.md">Protecting users</a> for details on default and known providers.</p></div><div id="rfc.section.4.4.p.4"><p>If no default provider is found or multiple providers exist, an intent is constructed for a dialog that will allow the user to choose a provider, after which an intent will be dispatched to that provider containing the descriptor.</p></div><div id="rfc.section.4.4.p.5"><p>The flow for creating a credential hint based on the descriptor is under the control of the provider, and not part of this specification. A hint constructed by the provider is returned to the app via the intent data carried by <span class="tt">onActivityResult</span>.</p></div></section><section id="retrieving-credentials"><h3 id="rfc.section.4.5"><a href="#rfc.section.4.5">4.5.</a>&nbsp;<a href="#retrieving-credentials">Retrieving credentials</a></h3><div id="rfc.section.4.5.p.1"><p>Credential retrieval requests are dispatched using the <a href="bbq-protocol.md">BBQ protocol</a> to all credential providers on the device simultaneously. This is particularly useful for users who have more than one credential provider, such as Smart Lock for Passwords (present on all devices with Google apps), and Dashlane, which the user has chosen to install. Such users are often in a state where disjoint sets of credentials are stored in each, so querying both increases the chance that a credential can be found.</p></div><div id="rfc.section.4.5.p.2" class="avoidbreakafter"><p>The BBQ protocol uses <a href="https://developer.android.com/guide/components/intents-filters.html">Android broadcast intents</a> with recipients specified by package name in order to asynchronously deliver requests and responses. A retrieval request carries the following information:</p></div><div id="rfc.section.4.5.p.3"><ul><li>The set of authentication mechanisms that are supported by the requester.<a class="self" href="#rfc.section.4.5.p.3">¶</a></li> </ul></div><div id="rfc.section.4.5.p.4"><p>It is recommended that an app send a credential request whenever a user would typically be required to sign in manually, and <em>before</em> any login UI is shown. Some intermediate UI (such as a loading screen) can be displayed while waiting for a response. If a credential is available, the entire manual sign-in flow can be skipped, resulting in an improved user experience.</p></div><div id="rfc.section.4.5.p.5"><p>Retrieval responses may carry an intent that can be used to retrieve a credential from a provider. Providers respond with no intent if they know that they do not have a credential for the provider, or if they refuse to service the request. Providers <em>may</em> respond with an intent even if they do not know that they have a credential available: providers which use a master password to encrypt their stores which is not stored to disk may require the user to take an action to unlock the store before an accurate answer can be determined.</p></div><div id="rfc.section.4.5.p.6"><p>Where an intent is returned, <a href="https://developer.android.com/training/basics/intents/result.html">startActivityForResult</a> is used to dispatch it, and the selected credential data (if any) is returned via <span class="tt">onActivityResult</span>.</p></div></section><section id="retrieve-request-messages"><h3 id="rfc.section.4.6"><a href="#rfc.section.4.6">4.6.</a>&nbsp;<a href="#retrieve-request-messages">Retrieve request messages</a></h3><pre>
message CredentialRetrieveRequest {
    repeated string       authMethods        = 2; // at least one required
    repeated KeyValuePair additionalParams   = 3;
}
</pre><div id="rfc.section.4.6.p.1"><p>The CredentialRetrieveRequest must explicitly specify all credentials qualifiers the client supports with the exception of the authentication domain which will determined implicitly via the callers package name.</p></div></section><section id="retrieve-response-messages"><h3 id="rfc.section.4.7"><a href="#rfc.section.4.7">4.7.</a>&nbsp;<a href="#retrieve-response-messages">Retrieve response messages</a></h3><pre>
message CredentialRetrieveResponse {
    optional bytes        retrieveIntent   = 1; // required
    repeated KeyValuePair additionalParams = 2;
}
</pre><div id="rfc.section.4.7.p.1"><p>Providers indicate whether they may be able to provide a credential to the requester by responding with a message that optionally contains an activity <a href="https://developer.android.com/reference/android/content/Intent.html">Intent</a> to retrieve the credential. The absence of an intent in the response indicates that the provider knows that it does not have an available credential, or is refusing to serve the request.</p></div><div id="rfc.section.4.7.p.2"><p>An activity intent is used for the final stage of retrieving the request to allow the credential provider to interact with the user in some way before releasing the credential. Many credential providers will require an unlock code (a PIN number, password or recognized fingerprint) in order to decrypt and release the credential, or may simply wish to notify the user that the credential is being released to avoid surprising the user.</p></div><div id="rfc.section.4.7.p.3"><p>If the requester receives more than one Intent-carrying response, the user should be prompted to choose between the available options. If no intent-carrying responses are received, then the requester should proceed to a manual sign-in.</p></div></section><section id="retrieve-intent-responses"><h3 id="rfc.section.4.8"><a href="#rfc.section.4.8">4.8.</a>&nbsp;<a href="#retrieve-intent-responses">Retrieve intent responses</a></h3><div id="rfc.section.4.8.p.1" class="avoidbreakafter"><p>The intent should be dispatched using <a href="https://developer.android.com/training/basics/intents/result.html">startActivityForResult</a>, allowing the response to be delivered to via <span class="tt">onActivityResult</span>. The provider can describe two outcomes to this process:</p></div><div id="rfc.section.4.8.p.2"><ul><li>The operation was canceled (indicated by <a href="https://developer.android.com/reference/android/app/Activity.html#RESULT_CANCELED">ACTIVITY_CANCELED</a>). This can occur as a result of the user failing to enter their unlock code correctly, or explicitly canceling the flow.</li> <li>The operation succeeded (indicated by <a href="https://developer.android.com/reference/android/app/Activity.html#RESULT_OK">ACTIVITY_OK</a>), and a credential is carried in the response. The credential is encrypted using the shared secret established by the BBQ protocol.<a class="self" href="#rfc.section.4.8.p.2">¶</a></li> </ul></div><div id="rfc.section.4.8.p.3"><p>When provided with a credential, the application should immediately attempt to use this credential, and should do so without requiring any additional user input (e.g. pressing a "sign in" button).</p></div></section></section><hr class="noprint"><section id="saving-credentials"><h2 id="rfc.section.5" class="np"><a href="#rfc.section.5">5.</a>&nbsp;<a href="#saving-credentials">Saving credentials</a></h2><div id="rfc.section.5.p.1"><p>When a user successfully authenticates with an app, either manually or via the OpenYOLO retrieve or assisted sign-up flows, this credential should be saved for future use. Manually saving credentials to a provider is frustrating and error-prone - the user must manually switch to the credential provider, and follow the provider-specific flow to manually enter their credential again for storage, with the possibility of typographical errors.</p></div><div id="rfc.section.5.p.2"><p>A significantly better user experience can be provided if the credential can be saved in-context, just after it has been verified by an app. OpenYOLO provides the mechanism to achieve this.</p></div><div id="rfc.section.5.p.3"><p>After a credential has been verified by an app, it should construct a representation of the credential to be saved by a credential provider. This can then be sent to be stored using the OpenYOLO aPI.</p></div><div id="rfc.section.5.p.4"><p>If a preferred credential provider can be determined by the OpenYOLO API, then it will construct an intent to send the save request to the provider, carrying the plain-text credential data in an intent extra. Similarly, if only one credential provider is available on the device and it is a "known" provider, the intent to directly interact with that provider will be constructed. See <a href="protecting-users.md">Protecting users</a> for details on default and known providers.</p></div><div id="rfc.section.5.p.5"><p>If no preferred provider is found, an intent is constructed for a dialog that will allow the user to choose a provider, after which an intent will be dispatched to that provider containing the credential.</p></div><div id="rfc.section.5.p.6"><p>The flow for saving the credential past this point is under the control of the provider, and not part of this specification. The outcome of the save operation (success or failure) is communicated back to the app via a result code to <span class="tt">onActivityResult</span>.</p></div><section id="supporting-save"><h3 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a>&nbsp;<a href="#supporting-save">Supporting save</a></h3><div id="rfc.section.5.1.p.1"><p>In order to save a credential, the OpenYOLO client must first query the system for the preferred credential provider, or any available providers which support saving a credential. This involves a <a href="https://developer.android.com/reference/android/content/pm/PackageManager.html">Package Manager</a> API call to find activities with action <span class="tt">org.openyolo.save</span> and category <span class="tt">org.openyolo</span>.</p></div><div id="rfc.section.5.1.p.2"><p>It is anticipated that some credential providers will only be able to store id-and-password based credentials, while others may support federated credentials. Such providers can be distinguished by requiring that providers declare their supported set of authentication methods via an intent filter, with a data URI filter based on the authentication method URI.</p></div><div id="rfc.section.5.1.p.3" class="avoidbreakafter"><p>For a credential provider which only supports id-and-password based credentials, this would look as follows:</p></div><pre>
&lt;activity
    android:name="com.example.provider.SaveCredentialActivity"
    android:theme="@style/AppTheme.Dialog"
    android:exported="true"
    android:excludeFromRecents="true"&gt;
  &lt;intent-filter&gt;
    &lt;action android:name="org.openyolo.save"/&gt;
    &lt;category android:name="org.openyolo" /&gt;
  &lt;/intent-filter&gt;
&lt;/activity&gt;
</pre><div id="rfc.section.5.1.p.4"><p>If a provider supports saving credentials for multiple authentication methods, then multiple data filters can be specified. If the data filter is omitted, this indicates the provider supports saving all credentials, regardless of authentication type.</p></div><div id="rfc.section.5.1.p.5" class="avoidbreakafter"><p>Given a credential object to be saved, the system can be queried to find all password managers which support saving this credential:</p></div><pre>
Intent saveIntent = new Intent("org.openyolo.save");
saveIntent.addCategory("org.openyolo");

// set the authentication type as a data parameter
saveIntent.setData(Uri.parse("openyolo://id-and-password"));

List&lt;ResolveInfo&gt; supportingProviders =
    getPackageManager().queryIntentActivities(saveIntent, 0);
</pre><div id="rfc.section.5.1.p.6"><p>This list should be presented to the user, in order to allow them to select which provider they wish to save the credential to.</p></div></section><section id="filtering-the-provider-list"><h3 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a>&nbsp;<a href="#filtering-the-provider-list">Filtering the provider list</a></h3><div id="rfc.section.5.2.p.1" class="avoidbreakafter"><p>The list of credential providers returned by querying the package manager may include unsafe options - it is important to further filter this list based on the following criteria:</p></div><div id="rfc.section.5.2.p.2"><ol><li><div><p>If the user has a preferred credential provider defined in the Google Play Services managed settings, and this credential provider is in the list, it should be used directly.</p></div></li> <li><div><p>If the user has a whitelist of credential providers defined in the Google Play Services managed settings, the dialog presented to the user for save should be restricted to these options.</p></div></li> <li><div><p>If Google Play Services is unavailable, all options should be displayed such that known providers are clearly distinguished from unknown providers. Selecting an unknown provider should require a second confirmation, to avoid the user accidentally interacting with an unknown provider by tapping on the wrong area of the screen.</p></div><a class="self" href="#rfc.section.5.2.p.2">¶</a></li> </ol></div><div id="rfc.section.5.2.p.3"><p><a href="protecting-users.md">Protecting the user from malicious providers</a> provides more information on how the Google Play Services settings and the known providers list are defined.</p></div></section><section id="behavior-of-the-save-intent"><h3 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3.</a>&nbsp;<a href="#behavior-of-the-save-intent">Behavior of the save intent</a></h3><div id="rfc.section.5.3.p.1"><p>The behavior of the activity or activities that implement the save flow is beyond the scope of this specification. However,. if a saved credential matches an existing credential by identifier and authentication method, and authentication domain, the credential provider should allow this to be automatically saved where possible. This will allow apps to easily update credentials in response to password change events.</p></div><div id="rfc.section.5.3.p.2"><p>To mitigate potential attempts to spoof a credential provider's UI, it is also recommended that a method of pushing the request to a full screen version of the provider is made available. This will allow security-conscious users to determine that it is really the credential provider they are interacting with, and not some attempt to phish their master password.</p></div></section><section id="save-response"><h3 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4.</a>&nbsp;<a href="#save-response">Save response</a></h3><div id="rfc.section.5.4.p.1" class="avoidbreakafter"><p>The save response, returned to the app via <span class="tt">onActivityResult</span>, can be one of two values:</p></div><div id="rfc.section.5.4.p.2"><ol><li><span class="tt">RESULT_OK</span>, if the credential is successfully saved.</li> <li><span class="tt">RESULT_CANCELLED</span>, if the credential was not saved for any reason. No further details need to be provided to the calling application, as the application is unlikely to be able to take any remedial action.<a class="self" href="#rfc.section.5.4.p.2">¶</a></li> </ol></div></section></section><hr class="noprint"><section id="the-android-application-programming-interface-api"><h2 id="rfc.section.6" class="np"><a href="#rfc.section.6">6.</a>&nbsp;<a href="#the-android-application-programming-interface-api">The Android Application Programming Interface (API)</a></h2></section><hr class="noprint"><section id="the-android-service-provider-interface-spi"><h2 id="rfc.section.7" class="np"><a href="#rfc.section.7">7.</a>&nbsp;<a href="#the-android-service-provider-interface-spi">The Android Service Provider Interface (SPI)</a></h2></section><hr class="noprint"><section id="rfc.authors" class="np"><h2><a href="#rfc.authors">Author's Address</a></h2><address><b>Iain McGinniss</b><br>Google, Inc.<br><br>EMail: <a href="mailto:iainmcgin@google.com">iainmcgin@google.com</a></address></section></body></html>