<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>OpenYOLO: In-Context Credential Management</title><script type="application/javascript">
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          var postfix = fragid.substring(2);
          if (postfix.startsWith("abstract")) {
            window.location.hash = prefix + postfix;
          } else if (postfix.startsWith("note-")) {
            window.location.hash = prefix + "note." + postfix.substring(5);
          } else {
            window.location.hash = prefix + "section." + postfix;
          }
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script><link rel="shortcut icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAADnUExURf////r6+r+/v/f39/3nzrS0tP7+/rOzs/iTHvmnR+vr6/j4+LW1tebm5urq6tvb2/z8/Lm5uc7OztnZ2fDw8MHBweTk5P/59Li4uLe3t7y8vLa2tv39/b29vdDQ0PjkzL6+vsO+ucPDw8vLy+/v7+Dg4PiWI/q6bvmoSeLi4v7z5vHx8fn5+fvBfv7x4tfX1/v7++7u7ujo6NPT08XFxeXl5fzUpuPj497e3sLCwru7u/mcMfvlzfzmzvzNl//79tLS0tra2szMzOnp6c3Nzdzc3PDq5d3d3fmbL+Hh4eDSw8bGxtXV1TGsX/AAAAD6SURBVDjLY2CgAdDCL62nroFPWlxXjYMTnwIWDo5Br4DZFqSAWwCrJCOvgwK7PEgBP6uSDx+6tICjNDsQQBSAWKK8DIZCCHkxKZCgpJMNSAGfLIjDasIuCJfXB4koOcvAHMnlwmMlCVTDBpVXBUpLW7Ah+ULEEqSFnRsiz8UKZBshe5NbDmwLuzZEgTKQKYweDsymxqKsEL+wSQAV6GALKANGMKUClGfCF5IihBSwCQJVMOOLCyFsjkQGYG+K4YtNTaACHnc2PNENjh4FXgHc6cEcHFk83l44E4yMKyi42BU5OKzNcKQmRk85JnZFDzt7fEmS0U2c+lkZAOAoE2iFNzVGAAAAAElFTkSuQmCC"><meta name="theme-color" content="#f38019"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><style type="text/css">
    @import url('https://fonts.googleapis.com/css?family=Noto+Sans:r,b,i,bi');
    @import url('https://fonts.googleapis.com/css?family=Roboto+Mono:r,b,i,bi');

    body {
      background-color: #fafafa;
      color: #5a5a5a;
      font-family: 'Noto Sans', sans-serif;
      font-size: 12pt;
      margin: 1em;
      overflow-wrap: break-word;
    }

    body > * {
      max-width: 50em;
      margin: auto;
      overflow-x: hidden;
    }

    #identifiers {
      margin: 8pt 0;
    }

    #identifiers > div {
    }

    #identifiers dt {
      display: inline;
      float: none;
      font-style: italic;
      vertical-align: top;
    }

    #identifiers dt:after {
      content: ": ";
      vertical-align: top;
    }

    #identifiers dd {
      display: inline;
      margin: 0;
    }

    .authors {
      display: block;
      text-align: center;
      margin-top: 0.5em;
    }

    .authors .author {
      display: inline-block;
      margin-right: 1.5em;
    }

    .authors .org {
      font-style: italic;
    }

    a {
      text-decoration: none;
      color: #f38019
    }

    a.smpl {
      color: black;
    }

    a:hover {
      text-decoration: underline;
    }

    a:active {
      text-decoration: underline;
    }

    address {
      margin-top: 1em;
      margin-left: 2em;
      font-style: normal;
    }

    

    samp, span.tt, code, pre {
      font-family: 'Roboto Mono', monospace;
    }

    

    cite {
      font-style: normal;
    }

    dl > dt {
      float: left;
      margin-right: 1em;
    }
    dl.nohang > dt {
      float: none;
    }
    dl > dd {
      margin-bottom: .5em;
    }
    dl.compact > dd {
      margin-bottom: .0em;
    }
    dl > dd > dl {
      margin-top: 0.5em;
    }
    ul.empty {
      list-style-type: none;
    }
    ul.empty li {
      margin-top: .5em;
    }
    dl p {
      margin-left: 0em;
    }
    dl.reference > dt {
      font-weight: bold;
    }

    h1 {
      color: #f38019;
      font-size: 150%;
      line-height: 18pt;
      font-weight: bold;
      text-align: center;
      margin-top: 8pt;
      margin-bottom: 0pt;
    }
    h2 {
      font-size: 130%;
      line-height: 21pt;
      page-break-after: avoid;
    }
    h2.np {
      page-break-before: always;
    }
    h3 {
      font-size: 120%;
      line-height: 15pt;
      page-break-after: avoid;
    }
    h4 {
      font-size: 110%;
      page-break-after: avoid;
    }
    h5, h6 {
      page-break-after: avoid;
    }
    h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
      color: black;
    }

    ol.la {
      list-style-type: lower-alpha;
    }
    ol.ua {
      list-style-type: upper-alpha;
    }
    ol p {
      margin-left: 0em;
    }
    

    pre {
      font-size: 11pt;
      background-color: #E0E0E0;
      padding: .25em;
      page-break-inside: avoid;
      overflow-x: auto;
    }

    

    pre.text2 {
      border-style: dotted;
      border-width: 1px;
      background-color: #E0E0E0;
    }
    pre.inline {
      background-color: white;
      padding: 0em;
      page-break-inside: auto;
      
    }
    pre.text {
      border-style: dotted;
      border-width: 1px;
      background-color: #fafafa;
    }
    pre.drawing {
      border-style: solid;
      border-width: 1px;
      background-color: #fafafa;
      padding: 2em;
    }

    

    table.header {
      border-spacing: 1px;
      width: 95%;
      font-size: 11pt;
      color: white;
    }
    td.top {
      vertical-align: top;
    }
    td.topnowrap {
      vertical-align: top;
      white-space: nowrap;
    }
    table.header td {
      background-color: #7c7d80;
      width: 50%;
      padding: 2px 8px;
    }

    

    ul.toc, ul.toc ul {
      list-style: none;
      padding-left: 0em;
    }

    ul.toc li {
      line-height: 150%;
      font-weight: bold;
      margin-left: 0em;
    }

    ul.toc li li {
      line-height: normal;
      font-weight: normal;
      font-size: 11pt;
      margin-left: 0em;
    }

    ul.toc a {
      color: #f38019;
    }

    li.excluded {
      font-size: 0pt;
    }
    ul p {
      margin-left: 0em;
    }
    .filename, h1, h2, h3, h4 {
      font-family: 'Noto Sans', segoe, optima, arial, sans-serif;
    }

    

    .comment {
      background-color: yellow;
    }

    

    .center {
      text-align: center;
    }

    .error {
      color: red;
      font-style: italic;
      font-weight: bold;
    }
    .figure {
      font-weight: bold;
      text-align: center;
      font-size: 10pt;
    }
    .filename {
      color: #5a5a5a;
      font-size: 112%;
      font-weight: bold;
      line-height: 21pt;
      text-align: center;
      margin-top: 0.25em;
    }
    .fn {
      font-weight: bold;
    }
    .left {
      text-align: left;
    }
    .right {
      text-align: right;
    }
    .warning {
      font-size: 130%;
      background-color: yellow;
    }

    

    @media screen {
      pre.text, pre.text2 {
        width: 69em;
      }
    }

    @media print {
      .noprint {
        display: none;
      }

      a {
        color: black;
        text-decoration: none;
      }

      table.header {
        width: 90%;
      }

      td.header {
        width: 50%;
        color: black;
        background-color: white;
        vertical-align: top;
        font-size: 110%;
      }

      ul.toc a:last-child::after {
        content: leader('.') target-counter(attr(href), page);
      }

      ul.ind li li a {
        content: target-counter(attr(href), page);
      }

      pre {
        font-size: 10pt;
      }

      .print2col {
        column-count: 2;
        -moz-column-count: 2;
        column-fill: auto;
      }

    
    }

    @page {
      @top-left {
          content: "Internet-Draft";
      }
      @top-right {
          content: "April 2017";
      }
      @top-center {
          content: "OpenYOLO";
      }
      @bottom-left {
          content: "McGinniss";
      }
      @bottom-center {
          content: "Expires October 16, 2017";
      }
      @bottom-right {
          content: "[Page " counter(page) "]";
      }
    }
    @page:first {
        @top-left {
          content: normal;
        }
        @top-right {
          content: normal;
        }
        @top-center {
          content: normal;
        }
    }

    @media only screen and (max-device-width: 480px) {
      p {
        text-align: justify;
        text-justify: distribute;
        -webkit-hyphens: auto;
      }

      pre {
        font-size: 9pt;
      }

      table.header {
        display: block;
        border-spacing: 1px;
        font-size: 11pt;
        color: white;
      }

      table.header tbody {
        display: flex;
        flex-direction: column;
      }

      table.header tr {
        display: run-in;
      }

      table.header td {
        display: block;
        background-color: #7c7d80;
        width: auto;
      }

      table.header td.left {
        order: 0;
      }

      table.header td.right {
        order: 1;
      }
    }
    </style><link rel="Contents" href="#rfc.toc"><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Why is authentication hard?" href="#rfc.section.1"><link rel="Chapter" title="2 Definitions" href="#rfc.section.2"><link rel="Chapter" title="3 Operations" href="#rfc.section.3"><link rel="Chapter" title="4 OpenYOLO for Android" href="#rfc.section.4"><link rel="Chapter" title="5 Background broadcast query protocol (BBQ)" href="#rfc.section.5"><link rel="Chapter" title="6 Retrieving Hints" href="#rfc.section.6"><link rel="Chapter" title="7 Retrieving credentials" href="#rfc.section.7"><link rel="Chapter" title="8 Saving credentials" href="#rfc.section.8"><link rel="Chapter" title="9 The Android Application Programming Interface (API)" href="#rfc.section.9"><link rel="Chapter" title="10 The Android Service Provider Interface (SPI)" href="#rfc.section.10"><link rel="Chapter" title="11 OpenYOLO for Web" href="#rfc.section.11"><meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.908, 2017/04/06 12:58:20, XSLT vendor: Saxonica http://www.saxonica.com/"><meta name="keywords" content="password, credential, security"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="McGinniss, I."><meta name="dcterms.identifier" content="urn:ietf:id:draft-openyolo-00"><meta name="dcterms.issued" content="2017-04-14"><meta name="dcterms.abstract" content="OpenYOLO is a protocol for retrieving, updating and assisting in the creation of authentication credentials. This document describes the core concepts of OpenYOLO, and platform-specific details for implementing the OpenYOLO protocol for Android apps and Progressive Web Applications (PWAs). What's in a name? YOLO stands for &#34;You Only Login Once&#34;, which was the internal code-name for Google's Smart Lock for Passwords API on Android. OpenYOLO is the open standard successor to YOLO - lessons learned from the implementation and usage of Smart Lock for Passwords has heavily influenced OpenYOLO."><meta name="description" content="OpenYOLO is a protocol for retrieving, updating and assisting in the creation of authentication credentials. This document describes the core concepts of OpenYOLO, and platform-specific details for implementing the OpenYOLO protocol for Android apps and Progressive Web Applications (PWAs). What's in a name? YOLO stands for &#34;You Only Login Once&#34;, which was the internal code-name for Google's Smart Lock for Passwords API on Android. OpenYOLO is the open standard successor to YOLO - lessons learned from the implementation and usage of Smart Lock for Passwords has heavily influenced OpenYOLO."></head><body><header><div id="rfc.title"><h1>OpenYOLO: In-Context Credential Management</h1><div class="filename">draft-openyolo-00</div></div><div class="authors"><div class="author"><div class="author-name">I. McGinniss</div><div class="org">Google, Inc.</div></div></div><dl id="identifiers"><div><dt>Stream</dt><dd class="workgroup">Account Chooser</dd></div><div><dt>Category</dt><dd>Experimental</dd></div><div><dt>Published</dt><dd>April&nbsp;14, 2017</dd></div><div><dt>Expires</dt><dd>October 16, 2017</dd></div></dl></header><section id="rfc.abstract"><h2><a href="#rfc.abstract">Abstract</a></h2><div id="rfc.abstract.p.1"><p>OpenYOLO is a protocol for retrieving, updating and assisting in the creation of authentication credentials. This document describes the core concepts of OpenYOLO, and platform-specific details for implementing the OpenYOLO protocol for Android apps and Progressive Web Applications (PWAs).</p></div><div id="rfc.abstract.p.2"><p><strong>What's in a name?</strong> </p></div><div id="rfc.abstract.p.3"><p>YOLO stands for "You Only Login Once", which was the internal code-name for Google's <a href="https://developers.google.com/identity/smartlock-passwords/android/">Smart Lock for Passwords</a> API on Android. OpenYOLO is the open standard successor to YOLO - lessons learned from the implementation and usage of Smart Lock for Passwords has heavily influenced OpenYOLO.</p></div></section><hr class="noprint"><nav id="rfc.toc"><h2 class="np"><a href="#rfc.toc">Table of Contents</a></h2><ul class="toc"><li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#why-is-authentication-hard">Why is authentication hard?</a><ul><li><a href="#rfc.section.1.1">1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#password-authentication">Password authentication</a></li><li><a href="#rfc.section.1.2">1.2.</a>&nbsp;&nbsp;&nbsp;<a href="#federated-authentication">Federated authentication</a></li><li><a href="#rfc.section.1.3">1.3.</a>&nbsp;&nbsp;&nbsp;<a href="#credential-managers">Credential managers</a></li><li><a href="#rfc.section.1.4">1.4.</a>&nbsp;&nbsp;&nbsp;<a href="#account-recovery-based-authentication">Account recovery based authentication</a></li><li><a href="#rfc.section.1.5">1.5.</a>&nbsp;&nbsp;&nbsp;<a href="#communication-the-missing-puzzle-piece">Communication: the missing puzzle piece</a></li></ul></li><li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#definitions">Definitions</a><ul><li><a href="#rfc.section.2.1">2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#credentials">Credentials</a></li><li><a href="#rfc.section.2.2">2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#credential-providers">Credential providers</a><ul><li><a href="#rfc.section.2.2.1">2.2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#known-and-unknown-providers">Known and unknown providers</a></li></ul></li><li><a href="#rfc.section.2.3">2.3.</a>&nbsp;&nbsp;&nbsp;<a href="#authentication-domains">Authentication domains</a></li><li><a href="#rfc.section.2.4">2.4.</a>&nbsp;&nbsp;&nbsp;<a href="#authentication-methods">Authentication methods</a></li></ul></li><li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#operations">Operations</a></li><li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#openyolo-for-android">OpenYOLO for Android</a></li><li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#background-broadcast-query-protocol-bbq">Background broadcast query protocol (BBQ)</a><ul><li><a href="#rfc.section.5.1">5.1.</a>&nbsp;&nbsp;&nbsp;<a href="#structure-of-a-request">Structure of a request</a></li><li><a href="#rfc.section.5.2">5.2.</a>&nbsp;&nbsp;&nbsp;<a href="#dispatching-a-request">Dispatching a request</a></li><li><a href="#rfc.section.5.3">5.3.</a>&nbsp;&nbsp;&nbsp;<a href="#structure-of-a-response">Structure of a response</a></li><li><a href="#rfc.section.5.4">5.4.</a>&nbsp;&nbsp;&nbsp;<a href="#receiving-a-response">Receiving a response</a></li><li><a href="#rfc.section.5.5">5.5.</a>&nbsp;&nbsp;&nbsp;<a href="#rooted-devices">Rooted devices</a></li></ul></li><li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#retrieving-hints">Retrieving Hints</a></li><li><a href="#rfc.section.7">7.</a>&nbsp;&nbsp;&nbsp;<a href="#retrieving-credentials">Retrieving credentials</a><ul><li><a href="#rfc.section.7.1">7.1.</a>&nbsp;&nbsp;&nbsp;<a href="#retrieve-request-messages">Retrieve request messages</a></li><li><a href="#rfc.section.7.2">7.2.</a>&nbsp;&nbsp;&nbsp;<a href="#retrieve-response-messages">Retrieve response messages</a></li><li><a href="#rfc.section.7.3">7.3.</a>&nbsp;&nbsp;&nbsp;<a href="#retrieve-intent-responses">Retrieve intent responses</a></li></ul></li><li><a href="#rfc.section.8">8.</a>&nbsp;&nbsp;&nbsp;<a href="#saving-credentials">Saving credentials</a><ul><li><a href="#rfc.section.8.1">8.1.</a>&nbsp;&nbsp;&nbsp;<a href="#supporting-save">Supporting save</a></li><li><a href="#rfc.section.8.2">8.2.</a>&nbsp;&nbsp;&nbsp;<a href="#filtering-the-provider-list">Filtering the provider list</a></li><li><a href="#rfc.section.8.3">8.3.</a>&nbsp;&nbsp;&nbsp;<a href="#behavior-of-the-save-intent">Behavior of the save intent</a></li><li><a href="#rfc.section.8.4">8.4.</a>&nbsp;&nbsp;&nbsp;<a href="#save-response">Save response</a></li></ul></li><li><a href="#rfc.section.9">9.</a>&nbsp;&nbsp;&nbsp;<a href="#the-android-application-programming-interface-api">The Android Application Programming Interface (API)</a></li><li><a href="#rfc.section.10">10.</a>&nbsp;&nbsp;&nbsp;<a href="#the-android-service-provider-interface-spi">The Android Service Provider Interface (SPI)</a></li><li><a href="#rfc.section.11">11.</a>&nbsp;&nbsp;&nbsp;<a href="#openyolo-for-web">OpenYOLO for Web</a></li><li><a href="#rfc.authors">Author's Address</a></li></ul></nav><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><div id="rfc.boilerplate.1.p.1"><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p></div><div id="rfc.boilerplate.1.p.2"><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p></div><div id="rfc.boilerplate.1.p.3"><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p></div><div id="rfc.boilerplate.1.p.4"><p>This Internet-Draft will expire on October 16, 2017.</p></div></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><div id="rfc.boilerplate.2.p.1"><p>Copyright © 2017 IETF Trust and the persons identified as the document authors. All rights reserved.</p></div><div id="rfc.boilerplate.2.p.2"><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></div></section><hr class="noprint"><section id="why-is-authentication-hard"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a href="#why-is-authentication-hard">Why is authentication hard?</a></h2><div id="rfc.section.1.p.1" class="avoidbreakafter"><p>The following screen is a common sight when interacting with services in an application or website:</p></div><pre>
+------------------------------------------+
|                                          |
|       To continue, please sign in:       |
|                                          |
|    Email                                 |
|   ------------------------------------   |
|                                          |
|    Password                              |
|   ------------------------------------   |
|                                          |
|   Forgotten your password? [Click here]  |
|                                          |
|   =============== Or: ================   |
|                                          |
|   +-------------+     +--------------+   |
|   |   Google    |     |   Facebook   |   |
|   +-------------+     +--------------+   |
|                                          |
|       If you don't have an account,      |
|                [click here]              |
|                                          |
+------------------------------------------+
</pre><div id="rfc.section.1.p.2" class="avoidbreakafter"><p>A user typically has to answer three questions in response to such a page:</p></div><div id="rfc.section.1.p.3"><ol><li>Have I already created an account for this service?</li> <li>How did I sign in?</li> <li>If I used a password, what was it?<a class="self" href="#rfc.section.1.p.3">¶</a></li> </ol></div><div id="rfc.section.1.p.4"><p>Answering these questions for all but the most frequently used applications and websites (henceforth referred to as <em>services</em>) is difficult. Users now typically interact with around <a href="https://blog.dashlane.com/infographic-online-overload-its-worse-than-you-thought/">100 apps or sites</a>, and many of those services are used less than once a month, for example to buy flowers or arrange air travel.</p></div><div id="rfc.section.1.p.5"><p>Long session durations can help, but only when the user interacts with the service on a single device. Purchasing a new device is a particularly painful experience due to the need to re-authenticate with all used services. A more general solution is required.</p></div><section id="password-authentication"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a>&nbsp;<a href="#password-authentication">Password authentication</a></h3><div id="rfc.section.1.1.p.1" class="avoidbreakafter"><p>Password based authentication, despite multiple attempts to displace it, remains the most common form of authentication in use today. Password authentication suffers from three key issues:</p></div><div id="rfc.section.1.1.p.2"><ul><li><div><p>Passwords are often <em>weak</em>. Most users do not know how to produce <a href="https://doi.org/10.1109/MSP.2004.81">high entropy passwords</a>. The basic strategies employed involve using combinations of common dictionary words, years and names, all of which easily succumb to social engineering and dictionary attacks.</p></div></li> <li><div><p>Password credentials are often <em>transferable</em>. The limits of humans to memorize long strings of random information is <a href="https://doi.org/10.1145/322796.322806">well studied</a>; the typical user cannot be expected to memorize more than 5 passwords for unrelated services. The natural consequence is that users frequently reuse their passwords, which when combined with email addresses as identifiers, makes the credentials transferable across unrelated services. If a password is uncovered for a user on one service, an attacker can simply try this credential on other services with a high success rate.</p></div></li> <li><div><p>Password credentials are often <em>long lived</em>. There is no intrinsic expiration time on a password credential, and password rotation is not uniformly enforced across all password using services. If a password is uncovered by an attacker, it can be used for a significant period of time, perhaps indefinitely.</p></div><a class="self" href="#rfc.section.1.1.p.2">¶</a></li> </ul></div><div id="rfc.section.1.1.p.3"><p>Even where a service does enforce password rotation, such as once a year, "digit rotation" is commonly employed by users to circumvent this: they simply increment a counter at some position in the password, typically at the end. This makes guessing future passwords from current passwords particularly easy for an attacker.</p></div><div id="rfc.section.1.1.p.4"><p>The problems that passwords cause can only get worse, as users interact with more and more services.</p></div></section><section id="federated-authentication"><h3 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2.</a>&nbsp;<a href="#federated-authentication">Federated authentication</a></h3><div id="rfc.section.1.2.p.1"><p>Federated authentication, in the form of <a href="https://tools.ietf.org/html/rfc6749">OAuth2</a> and <a href="http://openid.net/specs/openid-connect-core-1_0.html">OpenID Connect</a>, solves the problem of account overload by centralizing authentication for the user with a small number of trusted <em>identity providers</em>. Furthermore, by providing proof of authentication to a service (referred to as a <em>relying party</em> in this context) in the form of short lived bearer tokens and cryptographically signed <a href="https://tools.ietf.org/html/rfc7519">ID tokens</a>, overall security is significantly improved over password based authentication.</p></div><div id="rfc.section.1.2.p.2"><p>However, the success of federated authentication in the consumer space is still limited - OAuth2 and OpenID Connect are regarded as difficult to implement, and federated authentication was unnecessarily tainted by "social login" in the early 2010s. Federated authentication was associated with unnecessary and invasive sharing of personal information. This association has largely been undone, but the perception of privacy invasion lingers. As a result, many users still prefer to use password authentication over federated authentication - they feel more in control of their personal information by explicitly entering what they wish to share during account creation.</p></div><div id="rfc.section.1.2.p.3"><p>As such, in the short term federated authentication cannot be considered to be the solution to the problems with password authentication. An alternative solution that can work with the status quo is required.</p></div></section><section id="credential-managers"><h3 id="rfc.section.1.3"><a href="#rfc.section.1.3">1.3.</a>&nbsp;<a href="#credential-managers">Credential managers</a></h3><div id="rfc.section.1.3.p.1"><p>A <em>credential manager</em> can mitigate the worst properties of passwords, by removing the burden of memorization from the user. A credential manager can generate strong, unique password for each service a user interacts with. Credential managers can even take on the role of rotating passwords, so that passwords become shorter lived.</p></div><div id="rfc.section.1.3.p.2"><p>The most common credential manager that users encounter is the form-fill functionality provided by most web browsers. Technically knowledgeable users often also use a standalone credential manager application, which stores their passwords and other sensitive information in a strong cryptographic store.</p></div><div id="rfc.section.1.3.p.3" class="avoidbreakafter"><p>Credential managers, as currently employed, still suffer from some serious usability issues:</p></div><div id="rfc.section.1.3.p.4"><ul><li>When a credential manager is a standalone application, the user must typically switch to the password manager, find the relevant credential, and copy it manually into the service they are signing in to. This is easier with desktop browsers, where a browser plugin can allow a credential manager to automatically fill the password, or display it in a more convenient location for the user to copy. However, not all browsers support plugins, and in particular mobile Safari and Chrome do not allow them.<a class="self" href="#rfc.section.1.3.p.4">¶</a></li> </ul></div><div id="rfc.section.1.3.p.5"><p>Manually copying a password also represents a security risk in itself; it is possible for other applications installed on the device to monitor the clipboard and steal passwords that are copied out of the credential manager.</p></div><div id="rfc.section.1.3.p.6"><ul><li>Heuristics are necessary to detect and fill in login forms. Such heuristics are fragile to changes in the service, such as when they are redesigned or change path within the domain. Heuristics are employed because there is rarely any viable alternative: services do not provide sufficient information for a credential manager to do a better job.<a class="self" href="#rfc.section.1.3.p.6">¶</a></li> </ul></div><div id="rfc.section.1.3.p.7"><p>This problem is particularly acute when the login system employs an <em>identifier first</em> pattern, where collection of the identifier and a password are split across multiple stages. In such situations, heuristics typically fail to detect the relationship between the disparate forms.</p></div><div id="rfc.section.1.3.p.8"><ul><li><div><p>Credential managers are blind to relationships between apps and sites that share the same authentication system - saving a credential for one site does not automatically make this credential available on other, related sites.</p></div></li> <li><div><p>Credential managers are unaware of <em>federated authentication</em>: they cannot help the user remember if they signed in to the service using Google or Facebook, only whether they filled in an identifier and password.</p></div></li> <li><div><p>Credential managers are unaware of password restrictions in use on the site: how long they must be, whether they must include a number or symbol, etc. As such, <em>password generation</em> is also heuristic and based on a least common denominator schema that is acceptable to the majority of services.</p></div><a class="self" href="#rfc.section.1.3.p.8">¶</a></li> </ul></div><div id="rfc.section.1.3.p.9"><p>Finally, many users are just simply unaware of what a credential manager is, where to get one, or how to use them, which has limited the impact of credential managers significantly.</p></div></section><section id="account-recovery-based-authentication"><h3 id="rfc.section.1.4"><a href="#rfc.section.1.4">1.4.</a>&nbsp;<a href="#account-recovery-based-authentication">Account recovery based authentication</a></h3><div id="rfc.section.1.4.p.1" class="avoidbreakafter"><p>Without a credential manager, when users are faced with a login page for an infrequently used service, many simply resort to <em>account recovery</em> as their primary method of authentication. The account is initially created with an email address or phone number that the user has access to. When authentication is next required, the user just selects the "I forgot my password" option, and expects the following flow:</p></div><div id="rfc.section.1.4.p.2"><ol><li><div><p>An email will be sent containing a link to reset the password.</p></div></li> <li><div><p>The user changes the password, likely to either their current reused password, or something random.</p></div></li> <li><div><p>The user authenticates with the changed password.</p></div><a class="self" href="#rfc.section.1.4.p.2">¶</a></li> </ol></div><div id="rfc.section.1.4.p.3"><p>In effect, all that is required is that they prove they have access to the email address associated with their account. Knowing that this is possible, many users won't even attempt to remember their passwords for these sites.</p></div><div id="rfc.section.1.4.p.4"><p>Some services even use this method explicitly as the main form of authentication: <a href="https://www.slack.com">Slack</a> calls this "magic link" authentication, and sending authorization codes to a phone is essentially the same.</p></div><div id="rfc.section.1.4.p.5"><p>When considered in isolation, this approach is a rather absurd, inconvenient form of federated authentication. It is, however, easy for users to understand. The service that manages the email address is effectively the identity provider, and the "bearer token" is the email sent for account recovery.</p></div><div id="rfc.section.1.4.p.6"><p>One may also observe that the most common email providers are <em>also</em> OAuth2 or OpenID Connect identity providers: Google, Microsoft and Yahoo account for over 90% of the US market, according to a data analysis conducted by <a href="https://blog.mailchimp.com/major-email-provider-trends-in-2015-gmail-takes-a-really-big-lead/">MailChimp in 2015</a>.</p></div><div id="rfc.section.1.4.p.7"><p>If it were possible to provide "proof of access" to an email address directly to a service, sending the email itself would be unnecessary. This is what the proposed OpenID Fast Identity Verification flow does, by providing an ID token for an asserted email address, if the user currently has access.</p></div></section><section id="communication-the-missing-puzzle-piece"><h3 id="rfc.section.1.5"><a href="#rfc.section.1.5">1.5.</a>&nbsp;<a href="#communication-the-missing-puzzle-piece">Communication: the missing puzzle piece</a></h3><div id="rfc.section.1.5.p.1" class="avoidbreakafter"><p>One fundamental barrier to progress in improving both account security and the authentication user experience is that services and credential managers cannot talk to each other. If such a communication channel existed, then the following operations would be possible:</p></div><div id="rfc.section.1.5.p.2"><ul><li><div><p>Account creation facilitated by the credential manager. The service could describe to the credential manager what authentication methods it supports, and what password restrictions it has. In response, a credential provider could (with or without user assistance) select an email address and generate a strong, unique password that is guaranteed to work.</p></div></li> <li><div><p>Retrieval of existing credentials. At the appropriate moment, a service could request a credential, and have this automatically returned, or returned after some in-context user consent is solicited. This would be a marked improvement over the user manually finding and copying the credential, and minimizes the opportunity for the credential to be stolen in doing so.</p></div></li> <li><div><p>Maintenance of the credential manager store. When the service modifies an account, it can notify the credential manager of account changes. This information can be used to keep the credential store fresh.</p></div></li> <li><div><p>"Proof of access" to email addresses and phone numbers could be directly solicited. While the credential manager may not have the authority to generate an ID token for a given email address, it could act as a conduit to acquiring such a token.</p></div><a class="self" href="#rfc.section.1.5.p.2">¶</a></li> </ul></div><div id="rfc.section.1.5.p.3"><p>Defining a protocol for this communication channel is exactly what OpenYOLO aims to achieve. Furthermore, a <em>default</em> credential manager will be provided by the OpenID Foundation, with a limited set of functionality that still provides significant benefit to users who do not have a credential manager of their own.</p></div></section></section><hr class="noprint"><section id="definitions"><h2 id="rfc.section.2" class="np"><a href="#rfc.section.2">2.</a>&nbsp;<a href="#definitions">Definitions</a></h2><div id="rfc.section.2.p.1"><p>Before providing a high level overview of the OpenYOLO operations, some terms that will be used throughout the discussion must be defined. Where data structures are described, this document uses <a href="https://developers.google.com/protocol-buffers">Protocol Buffer v3 messages</a> as the definition language.</p></div><section id="credentials"><h3 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a>&nbsp;<a href="#credentials">Credentials</a></h3><div id="rfc.section.2.1.p.1"><p>A <em>credential</em> is a set of properties that are used to help authenticate a user. Credentials can be <em>partial</em>, where they do not provide all necessary information for authentication.</p></div><div id="rfc.section.2.1.p.2" class="avoidbreakafter"><p>Credentials in OpenYOLO are composed of the following properties:</p></div><div id="rfc.section.2.1.p.3"><ul><li><div><p>An <em>authentication domain</em>, where the credential can be used. The authentication domain is often <em>implicit</em>, inferred from the origin or Android package name of a service. However, all stored credentials must have an associated authentication domain - there are no "ephemeral" credentials.</p></div></li> <li><div><p>An <em>authentication method</em>, which describes the system used to verify the credential.</p></div></li> <li><div><p>An <em>identifier</em> which designates an account in the context of both the authentication domain and method. Typically, identifiers are email addresses, phone numbers, or some alphanumeric string. Identifiers are not always intended to be human readable.</p></div></li> <li><div><p>An optional <em>display name</em>, that assists the user in identifying and distinguishing credentials. Typically, the display name for a credential is the user's real name, or a chosen alias.</p></div></li> <li><div><p>An optional <em>display picture</em>, that fufills a similar role to display name. Typically, the display picture is either a picture of the user, an avatar that they have chosen, or one they been assigned.</p></div><a class="self" href="#rfc.section.2.1.p.3">¶</a></li> </ul></div><div id="rfc.section.2.1.p.4" class="avoidbreakafter"><p>Formally, a credential is structed as follows:</p></div><pre>
message Credential {
    string id                = 1; // required
    string authDomain        = 2; // required
    string authMethod        = 3; // required
    string displayName       = 4;
    string displayPictureUri = 5;
    string password          = 6;

    repeated KeyValuePair additionalProps = 7;
}
</pre><div id="rfc.section.2.1.p.5"><p>As password based credentials as so common, a field is reserved for this use on Credential messages.</p></div></section><section id="credential-providers"><h3 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a>&nbsp;<a href="#credential-providers">Credential providers</a></h3><div id="rfc.section.2.2.p.1" class="avoidbreakafter"><p>A <em>credential provider</em> is defined in OpenYOLO to be any application which provides the required broadcast receivers and activity intent filters to handle all OpenYOLO operations. Credential providers are typically one of the following:</p></div><div id="rfc.section.2.2.p.2"><ul><li><div><p>Dedicated apps whose sole purpose is to store and protect credentials a user has chosen to store.</p></div></li> <li><div><p>Browsers which save and form-fill credentials. Many sites have dedicated Android applications which can benefit from retrieving credentials that are already stored in the browser.</p></div></li> <li><div><p>System services such as Smart Lock for Passwords which can store credentials for the user in the absence of other installed alternatives.</p></div><a class="self" href="#rfc.section.2.2.p.2">¶</a></li> </ul></div><div id="rfc.section.2.2.p.3"><p>While any app can become a credential provider by supporting the required OpenYOLO endpoints, only apps for which credential management is a clearly declared and visible feature to the user should become credential providers. <a href="protecting-users.md">Protecting users</a> describes these criteria in more detail, and the technical counter-measures that are taken to make it difficult for inappropriate or malicious apps to be used as credential providers.</p></div><section id="known-and-unknown-providers"><h4 id="rfc.section.2.2.1"><a href="#rfc.section.2.2.1">2.2.1.</a>&nbsp;<a href="#known-and-unknown-providers">Known and unknown providers</a></h4><div id="rfc.section.2.2.1.p.1"><p>Given the sensitive nature of the data being exchanged by OpenYOLO, the protocol will become an obvious target for attackers. Attackers are likely to try and register themselves as credential providers, and attempt to trick users into providing credentials to them. Distinguishing legitimate credential providers from malicious providers is therefore an important aspect of building trust in the protocol, for both app developers and users.</p></div><div id="rfc.section.2.2.1.p.2"><p>In order to achieve this, a "known provider" list will be hosted by the OpenID Foundation. A static version of this list is included in the OpenYOLO API on each platform, and is automatically updated by client library when necessary.</p></div><div id="rfc.section.2.2.1.p.3"><p>An "unknown" provider will still be usable, however the experience will be deliberately downgraded in order to ensure the user is aware of the risks of using such a provider. Generally, this will entail asking for consent to proceed from the user before every OpenYOLO operation. Known providers will not have this restriction.</p></div><div id="rfc.section.2.2.1.p.4"><p>Where possible on each supported platform, the user <em>should</em> be able to store their preferred credential provider. Additional providers <em>may</em> still be used during credential retrieval, but the preferred provider is exclusively used for the purposes of saving and generating credentials. See the platform-specific sections for more details on how this preference is used and modified.</p></div></section></section><section id="authentication-domains"><h3 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3.</a>&nbsp;<a href="#authentication-domains">Authentication domains</a></h3><div id="rfc.section.2.3.p.1"><p>An <em>authentication domain</em> is defined in OpenYOLO to be a scope within which a credential is considered to be usable. Authentication domains are represented as absolute, hierarchical URIs of form <span class="tt">scheme://authority</span> - no path, query or fragment is permitted.</p></div><div id="rfc.section.2.3.p.2" class="avoidbreakafter"><p>Two forms of authentication domain are defined for OpenYOLO:</p></div><div id="rfc.section.2.3.p.3"><ul><li><div><p>Android authentication domains, of form <span class="tt">android://FINGERPRINT@PACKAGE</span> where <span class="tt">PACKAGE</span> is the package name of an app and <span class="tt">FINGERPRINT</span> is a Base64, URL-safe encoding of the app's public key (provided by the <a href="https://developer.android.com/reference/android/content/pm/Signature.html">Signature</a> type in Android). The fingerprint string includes both the hash used, and the hash data, e.g. <span class="tt">sha512-7fmduHK...</span>. All OpenYOLO credential providers <em>must</em> support both <span class="tt">sha256</span> and <span class="tt">sha512</span> for fingerprints.</p></div></li> <li><div><p>Web authentication domains, which match the domain of the site and can have either a http or https scheme (e.g. <span class="tt">https://example.com</span> and <span class="tt">http://www.example.com</span> are valid web authentication domains).</p></div><a class="self" href="#rfc.section.2.3.p.3">¶</a></li> </ul></div><div id="rfc.section.2.3.p.4"><p>A single <em>authentication system</em>, which maintains and validates credentials, may be represented by multiple distinct authentication domains. For example, a credential for <span class="tt">android://...@com.example.app</span> may be usable on <span class="tt">https://example.com</span> or <span class="tt">https://www.example.com</span>, when these three entities all use the same authentication system. However, it is important that <span class="tt">android://HASH-A@com.example.app</span> and <span class="tt">android://HASH-B@com.example.app</span> should not be treated as equivalent <em>automatically</em> - either could represent a compromised, side-loaded variant of an app that is attempting to steal user credentials.</p></div><div id="rfc.section.2.3.p.5"><p>An authentication domain <em>equivalence class</em> defines the set of authentication domains across which a given credential can be freely shared. Such equivalence classes improve the usability of OpenYOLO, but must be carefully defined to avoid compromising the security of a user's credentials.</p></div><div id="rfc.section.2.3.p.6"><p>OpenYOLO recommends the use of the <a href="https://developers.google.com/digital-asset-links/">Digital Asset Links</a> as a standard source of app and site relationships. Credential providers <em>should</em> use this information as part of defining the equivalence class over authentication domains, but they may also use additional information. It is the responsibility of the credential provider to correctly construct and enforce the authentication domain equivalence class.</p></div></section><section id="authentication-methods"><h3 id="rfc.section.2.4"><a href="#rfc.section.2.4">2.4.</a>&nbsp;<a href="#authentication-methods">Authentication methods</a></h3><div id="rfc.section.2.4.p.1" class="avoidbreakafter"><p>An <em>authentication method</em> is a mechanism by which a user credential can be verified, and is given a unique URI identifier. Any URI of form <span class="tt">scheme://authority</span> can be used to describe an authentication method; OpenYOLO defines some standard URIs for the two most common types of authentication method:</p></div><div id="rfc.section.2.4.p.2"><ul><li><div><p>Identifier and password based authentication under the direct control of the app, where the identifier and password are non-empty strings composed of printable ASCII characters. The URI for this authentication method is standardized as <span class="tt">openyolo://id-and-password</span>.</p></div></li> <li><div><p>Federated credentials (e.g. OpenID Connect), where a user identifier is passed to an identity provider (that is typically not controlled by the app). with some supporting information that identifies the app. The URI used to denote authentication with an identity provider is based upon the origin to which federated requests are typically sent for that provider. For example, the URI that should be used for Google Sign-in accounts is <span class="tt">https://accounts.google.com</span>, while the URI that should be used for Facebook Sign-in accounts is <span class="tt">https://www.facebook.com</span>. Other common federated identity provider URIs are defined in the OpenYOLO specification. Any authentication mechanism with protocol http or https is assumed to represent an federated identity provider.</p></div><a class="self" href="#rfc.section.2.4.p.2">¶</a></li> </ul></div></section></section><hr class="noprint"><section id="operations"><h2 id="rfc.section.3" class="np"><a href="#rfc.section.3">3.</a>&nbsp;<a href="#operations">Operations</a></h2></section><hr class="noprint"><section id="openyolo-for-android"><h2 id="rfc.section.4" class="np"><a href="#rfc.section.4">4.</a>&nbsp;<a href="#openyolo-for-android">OpenYOLO for Android</a></h2></section><hr class="noprint"><section id="background-broadcast-query-protocol-bbq"><h2 id="rfc.section.5" class="np"><a href="#rfc.section.5">5.</a>&nbsp;<a href="#background-broadcast-query-protocol-bbq">Background broadcast query protocol (BBQ)</a></h2><div id="rfc.section.5.p.1"><p>BBQ is a protocol designed to allow an Android app to request data from multiple <em>data providers</em> on the device, in parallel. Requests and responses are sent as targeted broadcast messages, with protocol buffers used to encode the request and response data. The use of broadcast messages allows implementations to be fully asynchronous, and protocol buffers allow messages to be compact and efficient, while avoiding common issues with custom Parcelable types.</p></div><section id="structure-of-a-request"><h3 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a>&nbsp;<a href="#structure-of-a-request">Structure of a request</a></h3><div id="rfc.section.5.1.p.1" class="avoidbreakafter"><p>A broadcast query has the following mandatory properties:</p></div><div id="rfc.section.5.1.p.2"><ul><li>The data type being requested, described with <a href="https://en.wikipedia.org/wiki/Reverse_domain_name_notation">reverse domain name notation</a>, as is typically used for package names and intent actions in Android. For example, <span class="tt">org.openyolo.credential</span>.</li> <li>The package name of the requesting app, e.g. <span class="tt">com.example.app</span>.</li> <li>A randomly generated, 64-bit request ID. This is used to distinguish the request from other requests with the same data type that may not have been fully resolved.</li> <li>A randomly generated, 64-bit response ID. A separate response ID is generated for each expected responder, allowing responders to be distinguished and their identity to be recovered from the mapping of response ID to package name that is created prior to sending the request.</li> <li>A description of the cryptographic scheme used for the exchange: <div><ul><li>A string that uniquely identifies the scheme.</li> <li>A set of key-value pairs carrying scheme-specific parameters.</li> </ul></div><a class="self" href="#rfc.section.5.1.p.2">¶</a></li> </ul></div><div id="rfc.section.5.1.p.3"><p>An additional data-type specific message can be carried in the request if necessary, in the form of a byte-array (typically an encoded protocol buffer). Additional parameters can also be encoded into the message as key-value pairs, allowing for extension of the protocol itself.</p></div><div id="rfc.section.5.1.p.4"><p>The request is encoded using a <a href="https://developers.google.com/protocol-buffers">protocol buffer (v2) message</a>. Following the current guidance for protocol buffer message definitions, all fields are marked <span class="tt">optional</span> or <span class="tt">repeated</span> to provide flexibility in changing this specification in future. Fields currently considered to be required are marked as such with a comment.</p></div><pre>
message BroadcastQuery {
  string   dataType         = 1; // required
  string   requestingApp    = 2; // required
  sfixed64 requestId        = 3; // required
  sfixed64 responseId       = 4; // required
  bytes    queryMessage     = 5;

  repeated Parameter additionalParams = 6;
}

message Parameter {
  string name  = 1; // required
  bytes  value = 2;
}
</pre></section><section id="dispatching-a-request"><h3 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a>&nbsp;<a href="#dispatching-a-request">Dispatching a request</a></h3><div id="rfc.section.5.2.p.1" class="avoidbreakafter"><p>A request is dispatched as one or more targeted broadcast intents. First, the requester uses the Android <a href="https://developer.android.com/reference/android/content/pm/PackageManager.html">PackageManager</a> API to determine the set of apps which can provide data of the required type:</p></div><pre>
Intent intent = new Intent(dataType);
intent.addCategory(BBQ_CATEGORY);
List&lt;ResolveInfo&gt; responderInfos =
    packageManager.queryBroadcastReceivers(intent, 0);
</pre><div id="rfc.section.5.2.p.2" class="avoidbreakafter"><p>A separate request is created for each potential responder, with a unique response ID, and sent as a targeted broadcast:</p></div><pre>
BroadcastQuery query = new BroadcastQuery.Builder()
    /* ... */
    .setResponseId(idForResponder.get(responder))
    .build();
Intent bbqIntent = new Intent(dataType);
bbqIntent.setPackage(responder);
bbqIntent.setExtra(EXTRA_QUERY_MESSAGE, query.encode());
context.sendBroadcast(bbqIntent);
</pre></section><section id="structure-of-a-response"><h3 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3.</a>&nbsp;<a href="#structure-of-a-response">Structure of a response</a></h3><div id="rfc.section.5.3.p.1" class="avoidbreakafter"><p>A broadcast query response has the following mandatory properties:</p></div><div id="rfc.section.5.3.p.2"><ul><li>The 64-bit request ID that the response is associated with, copied from the request.</li> <li>The 64-bit response ID unique to this response, copied from the request.<a class="self" href="#rfc.section.5.3.p.2">¶</a></li> </ul></div><div id="rfc.section.5.3.p.3"><p>Query responses are also represented as a V2 protocol buffer messages. The response copies the request and response IDs from the request message, and may include a data-type specific response message, if necessary. The absence of a data-type specific response message is generally interpreted to mean that the provider is unable to service the request.</p></div><div id="rfc.section.5.3.p.4" class="avoidbreakafter"><p>The structure of the query response message is therefore as follows:</p></div><pre>
message BroadcastQueryResponse {
  optional sfixed64  requestId             = 1; // required
  optional sfixed64  responseId            = 2; // required
  optional bytes     responseMessage       = 3;
  repeated Parameter additionalParams      = 4;
}
</pre></section><section id="receiving-a-response"><h3 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4.</a>&nbsp;<a href="#receiving-a-response">Receiving a response</a></h3><div id="rfc.section.5.4.p.1"><p>Responses are sent back to the requester in the form of targeted broadcasts. The requester dynamically registers a broadcast receiver to capture responses. The <em>ACTION</em> for the response is the requested data type with the request ID concatenated in zero-padded hex form, e.g. "org.openyolo.credential:000000000000CAFE" where "org.openyolo.credential" is the requested data type and "000000000000CAFE" is the request ID (51966 in decimal).</p></div><pre>
IntentFilter filter = new IntentFilter();
filter.addAction(encodeAction(dataType, requestId));
filter.addCategory(BBQ_CATEGORY);
context.registerReceiver(new BroadcastReciever() { ... }, filter);
</pre><div id="rfc.section.5.4.p.2"><p>In order to avoid waiting indefinitely for responses from faulty receivers, a timeout should be used, after which absent responses should be treated as though the provider was unable to service the request (equivalent to responding with no data-type specific message payload).</p></div></section><section id="rooted-devices"><h3 id="rfc.section.5.5"><a href="#rfc.section.5.5">5.5.</a>&nbsp;<a href="#rooted-devices">Rooted devices</a></h3><div id="rfc.section.5.5.p.1"><p>The BBQ protocol relies on the integrity of the Android broadcast system (and the <span class="tt">setPackage</span> mechanism in particular) to guarantee the privacy of the messages sent between a requester and a provider. On a rooted device, it is potentially possible for a malicious app or system service with root access to read these messages, and expose plain-text passwords.</p></div><div id="rfc.section.5.5.p.2"><p>Cryptography provides no additional protection. If an attacker can read the private messages sent via the broadcast system, this will typically imply they have access to the memory location of the buffers. If ephemeral public-private key pairs are used, which don't authenticate either party, a man-in-the-middle attack is possible.</p></div><div id="rfc.section.5.5.p.3" class="avoidbreakafter"><p>There is no trusted third party which can sign keys to prove they are associated to a particular app:</p></div><div id="rfc.section.5.5.p.4"><ul><li><div><p>Key pairs cannot be distributed with the app, as they could be easily extracted from the application in advance, or on-demand with root access on the device.</p></div></li> <li><div><p>Keys cannot be dynamically signed by a trusted entity on the device (such as the platform itself, or Google Play Services) as these exchanges would also be susceptible to attack by anything with root access.</p></div><a class="self" href="#rfc.section.5.5.p.4">¶</a></li> </ul></div><div id="rfc.section.5.5.p.5" class="avoidbreakafter"><p>As such, we strongly recommend that password manager apps disable the OpenYOLO protocol on rooted devices, if they are able to detect this. The option could be given to the user to re-enable the feature, with a warning as to the security risks of doing this. Generally, rooted devices are very risky to a user's security, so warning users of this fact prior to even allowing a password manager to be configured is also advisable, as the following attacks are also possible:</p></div><div id="rfc.section.5.5.p.6"><ul><li>Directly reading keys and passwords from the memory space of the password manager or app</li> <li>Scraping the contents of EditText instances for passwords</li> <li>Key-logging the user</li> <li>Injecting code into the process space of the password manager or app<a class="self" href="#rfc.section.5.5.p.6">¶</a></li> </ul></div><div id="rfc.section.5.5.p.7"><p>The authors of this specification have no evidence that the kernel modifications required to break this protocol exist on real devices, but they are certainly feasible. As such, all rooted devices should be treated with suspicion when using the BBQ protocol to transport security- or privacy-sensitive data.</p></div></section></section><hr class="noprint"><section id="retrieving-hints"><h2 id="rfc.section.6" class="np"><a href="#rfc.section.6">6.</a>&nbsp;<a href="#retrieving-hints">Retrieving Hints</a></h2><div id="rfc.section.6.p.1"><p>If no existing credentials can be retrieved from a credential provider, then OpenYOLO provides a fall-back mechanism that can be used to help in creating a new account. This mechanism will typically allow a new user account to be created without the need to manually enter any information.</p></div><div id="rfc.section.6.p.2"><p>First, the app must provide a descriptor of the types of credentials that it can support. This is done by providing a list of one or more supported authentication methods. If password authentication is supported, then a <em>password specification</em> can optionally be provided that describes the set of passwords that the app supports.</p></div><div id="rfc.section.6.p.3"><p>This descriptor can then be sent to a credential provider using the OpenYOLO API in order to derive a credential hint. If a default credential provider can be determined by the OpenYOLO API, then it will construct an intent to send the descriptor to this provider and return it for the app to dispatch when ready. Similarly, if only one credential provider is available on the device and it is a "known" provider, then an intent to directly interact with that provider will be constructed and returned. See <a href="protecting-users.md">Protecting users</a> for details on default and known providers.</p></div><div id="rfc.section.6.p.4"><p>If no default provider is found or multiple providers exist, an intent is constructed for a dialog that will allow the user to choose a provider, after which an intent will be dispatched to that provider containing the descriptor.</p></div><div id="rfc.section.6.p.5"><p>The flow for creating a credential hint based on the descriptor is under the control of the provider, and not part of this specification. A hint constructed by the provider is returned to the app via the intent data carried by <span class="tt">onActivityResult</span>.</p></div></section><hr class="noprint"><section id="retrieving-credentials"><h2 id="rfc.section.7" class="np"><a href="#rfc.section.7">7.</a>&nbsp;<a href="#retrieving-credentials">Retrieving credentials</a></h2><div id="rfc.section.7.p.1"><p>Credential retrieval requests are dispatched using the <a href="bbq-protocol.md">BBQ protocol</a> to all credential providers on the device simultaneously. This is particularly useful for users who have more than one credential provider, such as Smart Lock for Passwords (present on all devices with Google apps), and Dashlane, which the user has chosen to install. Such users are often in a state where disjoint sets of credentials are stored in each, so querying both increases the chance that a credential can be found.</p></div><div id="rfc.section.7.p.2" class="avoidbreakafter"><p>The BBQ protocol uses <a href="https://developer.android.com/guide/components/intents-filters.html">Android broadcast intents</a> with recipients specified by package name in order to asynchronously deliver requests and responses. A retrieval request carries the following information:</p></div><div id="rfc.section.7.p.3"><ul><li>The set of authentication mechanisms that are supported by the requester.<a class="self" href="#rfc.section.7.p.3">¶</a></li> </ul></div><div id="rfc.section.7.p.4"><p>It is recommended that an app send a credential request whenever a user would typically be required to sign in manually, and <em>before</em> any login UI is shown. Some intermediate UI (such as a loading screen) can be displayed while waiting for a response. If a credential is available, the entire manual sign-in flow can be skipped, resulting in an improved user experience.</p></div><div id="rfc.section.7.p.5"><p>Retrieval responses may carry an intent that can be used to retrieve a credential from a provider. Providers respond with no intent if they know that they do not have a credential for the provider, or if they refuse to service the request. Providers <em>may</em> respond with an intent even if they do not know that they have a credential available: providers which use a master password to encrypt their stores which is not stored to disk may require the user to take an action to unlock the store before an accurate answer can be determined.</p></div><div id="rfc.section.7.p.6"><p>Where an intent is returned, <a href="https://developer.android.com/training/basics/intents/result.html">startActivityForResult</a> is used to dispatch it, and the selected credential data (if any) is returned via <span class="tt">onActivityResult</span>.</p></div><section id="retrieve-request-messages"><h3 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a>&nbsp;<a href="#retrieve-request-messages">Retrieve request messages</a></h3><pre>
message CredentialRetrieveRequest {
    repeated string       authMethods        = 2; // at least one required
    repeated KeyValuePair additionalParams   = 3;
}
</pre><div id="rfc.section.7.1.p.1"><p>The CredentialRetrieveRequest must explicitly specify all credentials qualifiers the client supports with the exception of the authentication domain which will determined implicitly via the callers package name.</p></div></section><section id="retrieve-response-messages"><h3 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a>&nbsp;<a href="#retrieve-response-messages">Retrieve response messages</a></h3><pre>
message CredentialRetrieveResponse {
    optional bytes        retrieveIntent   = 1; // required
    repeated KeyValuePair additionalParams = 2;
}
</pre><div id="rfc.section.7.2.p.1"><p>Providers indicate whether they may be able to provide a credential to the requester by responding with a message that optionally contains an activity <a href="https://developer.android.com/reference/android/content/Intent.html">Intent</a> to retrieve the credential. The absence of an intent in the response indicates that the provider knows that it does not have an available credential, or is refusing to serve the request.</p></div><div id="rfc.section.7.2.p.2"><p>An activity intent is used for the final stage of retrieving the request to allow the credential provider to interact with the user in some way before releasing the credential. Many credential providers will require an unlock code (a PIN number, password or recognized fingerprint) in order to decrypt and release the credential, or may simply wish to notify the user that the credential is being released to avoid surprising the user.</p></div><div id="rfc.section.7.2.p.3"><p>If the requester receives more than one Intent-carrying response, the user should be prompted to choose between the available options. If no intent-carrying responses are received, then the requester should proceed to a manual sign-in.</p></div></section><section id="retrieve-intent-responses"><h3 id="rfc.section.7.3"><a href="#rfc.section.7.3">7.3.</a>&nbsp;<a href="#retrieve-intent-responses">Retrieve intent responses</a></h3><div id="rfc.section.7.3.p.1" class="avoidbreakafter"><p>The intent should be dispatched using <a href="https://developer.android.com/training/basics/intents/result.html">startActivityForResult</a>, allowing the response to be delivered to via <span class="tt">onActivityResult</span>. The provider can describe two outcomes to this process:</p></div><div id="rfc.section.7.3.p.2"><ul><li>The operation was canceled (indicated by <a href="https://developer.android.com/reference/android/app/Activity.html#RESULT_CANCELED">ACTIVITY_CANCELED</a>). This can occur as a result of the user failing to enter their unlock code correctly, or explicitly canceling the flow.</li> <li>The operation succeeded (indicated by <a href="https://developer.android.com/reference/android/app/Activity.html#RESULT_OK">ACTIVITY_OK</a>), and a credential is carried in the response. The credential is encrypted using the shared secret established by the BBQ protocol.<a class="self" href="#rfc.section.7.3.p.2">¶</a></li> </ul></div><div id="rfc.section.7.3.p.3"><p>When provided with a credential, the application should immediately attempt to use this credential, and should do so without requiring any additional user input (e.g. pressing a "sign in" button).</p></div></section></section><hr class="noprint"><section id="saving-credentials"><h2 id="rfc.section.8" class="np"><a href="#rfc.section.8">8.</a>&nbsp;<a href="#saving-credentials">Saving credentials</a></h2><div id="rfc.section.8.p.1"><p>When a user successfully authenticates with an app, either manually or via the OpenYOLO retrieve or assisted sign-up flows, this credential should be saved for future use. Manually saving credentials to a provider is frustrating and error-prone - the user must manually switch to the credential provider, and follow the provider-specific flow to manually enter their credential again for storage, with the possibility of typographical errors.</p></div><div id="rfc.section.8.p.2"><p>A significantly better user experience can be provided if the credential can be saved in-context, just after it has been verified by an app. OpenYOLO provides the mechanism to achieve this.</p></div><div id="rfc.section.8.p.3"><p>After a credential has been verified by an app, it should construct a representation of the credential to be saved by a credential provider. This can then be sent to be stored using the OpenYOLO aPI.</p></div><div id="rfc.section.8.p.4"><p>If a preferred credential provider can be determined by the OpenYOLO API, then it will construct an intent to send the save request to the provider, carrying the plain-text credential data in an intent extra. Similarly, if only one credential provider is available on the device and it is a "known" provider, the intent to directly interact with that provider will be constructed. See <a href="protecting-users.md">Protecting users</a> for details on default and known providers.</p></div><div id="rfc.section.8.p.5"><p>If no preferred provider is found, an intent is constructed for a dialog that will allow the user to choose a provider, after which an intent will be dispatched to that provider containing the credential.</p></div><div id="rfc.section.8.p.6"><p>The flow for saving the credential past this point is under the control of the provider, and not part of this specification. The outcome of the save operation (success or failure) is communicated back to the app via a result code to <span class="tt">onActivityResult</span>.</p></div><section id="supporting-save"><h3 id="rfc.section.8.1"><a href="#rfc.section.8.1">8.1.</a>&nbsp;<a href="#supporting-save">Supporting save</a></h3><div id="rfc.section.8.1.p.1"><p>In order to save a credential, the OpenYOLO client must first query the system for the preferred credential provider, or any available providers which support saving a credential. This involves a <a href="https://developer.android.com/reference/android/content/pm/PackageManager.html">Package Manager</a> API call to find activities with action <span class="tt">org.openyolo.save</span> and category <span class="tt">org.openyolo</span>.</p></div><div id="rfc.section.8.1.p.2"><p>It is anticipated that some credential providers will only be able to store id-and-password based credentials, while others may support federated credentials. Such providers can be distinguished by requiring that providers declare their supported set of authentication methods via an intent filter, with a data URI filter based on the authentication method URI.</p></div><div id="rfc.section.8.1.p.3" class="avoidbreakafter"><p>For a credential provider which only supports id-and-password based credentials, this would look as follows:</p></div><pre>
&lt;activity
    android:name="com.example.provider.SaveCredentialActivity"
    android:theme="@style/AppTheme.Dialog"
    android:exported="true"
    android:excludeFromRecents="true"&gt;
  &lt;intent-filter&gt;
    &lt;action android:name="org.openyolo.save"/&gt;
    &lt;category android:name="org.openyolo" /&gt;
    &lt;!--
    as this app only supports saving ID and password based credentials, this is
    declared using a data filter.
    --&gt;
    &lt;data
        android:scheme="openyolo"
        android:host="id-and-password" /&gt;
  &lt;/intent-filter&gt;
&lt;/activity&gt;
</pre><div id="rfc.section.8.1.p.4"><p>If a provider supports saving credentials for multiple authentication methods, then multiple data filters can be specified. If the data filter is omitted, this indicates the provider supports saving all credentials, regardless of authentication type.</p></div><div id="rfc.section.8.1.p.5" class="avoidbreakafter"><p>Given a credential object to be saved, the system can be queried to find all password managers which support saving this credential:</p></div><pre>
Intent saveIntent = new Intent("org.openyolo.save");
saveIntent.addCategory("org.openyolo");

// set the authentication type as a data parameter
saveIntent.setData(Uri.parse("openyolo://id-and-password"));

List&lt;ResolveInfo&gt; supportingProviders =
    getPackageManager().queryIntentActivities(saveIntent, 0);
</pre><div id="rfc.section.8.1.p.6"><p>This list should be presented to the user, in order to allow them to select which provider they wish to save the credential to.</p></div></section><section id="filtering-the-provider-list"><h3 id="rfc.section.8.2"><a href="#rfc.section.8.2">8.2.</a>&nbsp;<a href="#filtering-the-provider-list">Filtering the provider list</a></h3><div id="rfc.section.8.2.p.1" class="avoidbreakafter"><p>The list of credential providers returned by querying the package manager may include unsafe options - it is important to further filter this list based on the following criteria:</p></div><div id="rfc.section.8.2.p.2"><ol><li><div><p>If the user has a preferred credential provider defined in the Google Play Services managed settings, and this credential provider is in the list, it should be used directly.</p></div></li> <li><div><p>If the user has a whitelist of credential providers defined in the Google Play Services managed settings, the dialog presented to the user for save should be restricted to these options.</p></div></li> <li><div><p>If Google Play Services is unavailable, all options should be displayed such that known providers are clearly distinguished from unknown providers. Selecting an unknown provider should require a second confirmation, to avoid the user accidentally interacting with an unknown provider by tapping on the wrong area of the screen.</p></div><a class="self" href="#rfc.section.8.2.p.2">¶</a></li> </ol></div><div id="rfc.section.8.2.p.3"><p><a href="protecting-users.md">Protecting the user from malicious providers</a> provides more information on how the Google Play Services settings and the known providers list are defined.</p></div></section><section id="behavior-of-the-save-intent"><h3 id="rfc.section.8.3"><a href="#rfc.section.8.3">8.3.</a>&nbsp;<a href="#behavior-of-the-save-intent">Behavior of the save intent</a></h3><div id="rfc.section.8.3.p.1"><p>The behavior of the activity or activities that implement the save flow is beyond the scope of this specification. However,. if a saved credential matches an existing credential by identifier and authentication method, and authentication domain, the credential provider should allow this to be automatically saved where possible. This will allow apps to easily update credentials in response to password change events.</p></div><div id="rfc.section.8.3.p.2"><p>To mitigate potential attempts to spoof a credential provider's UI, it is also recommended that a method of pushing the request to a full screen version of the provider is made available. This will allow security-conscious users to determine that it is really the credential provider they are interacting with, and not some attempt to phish their master password.</p></div></section><section id="save-response"><h3 id="rfc.section.8.4"><a href="#rfc.section.8.4">8.4.</a>&nbsp;<a href="#save-response">Save response</a></h3><div id="rfc.section.8.4.p.1" class="avoidbreakafter"><p>The save response, returned to the app via <span class="tt">onActivityResult</span>, can be one of two values:</p></div><div id="rfc.section.8.4.p.2"><ol><li><span class="tt">RESULT_OK</span>, if the credential is successfully saved.</li> <li><span class="tt">RESULT_CANCELLED</span>, if the credential was not saved for any reason. No further details need to be provided to the calling application, as the application is unlikely to be able to take any remedial action.<a class="self" href="#rfc.section.8.4.p.2">¶</a></li> </ol></div></section></section><hr class="noprint"><section id="the-android-application-programming-interface-api"><h2 id="rfc.section.9" class="np"><a href="#rfc.section.9">9.</a>&nbsp;<a href="#the-android-application-programming-interface-api">The Android Application Programming Interface (API)</a></h2></section><hr class="noprint"><section id="the-android-service-provider-interface-spi"><h2 id="rfc.section.10" class="np"><a href="#rfc.section.10">10.</a>&nbsp;<a href="#the-android-service-provider-interface-spi">The Android Service Provider Interface (SPI)</a></h2></section><hr class="noprint"><section id="openyolo-for-web"><h2 id="rfc.section.11" class="np"><a href="#rfc.section.11">11.</a>&nbsp;<a href="#openyolo-for-web">OpenYOLO for Web</a></h2><div id="rfc.section.11.p.1"><p>The OpenYOLO protocol is implemented on Web by opening a hidden iframe for a credential manager, and establishing a message channel with it to exchange protocol messages. Through this approach, no browser plugins are required, and the credential provider can be displayed in-context simply by making the hidden iframe visible.</p></div><div id="rfc.section.11.p.2"><p>Securing the OpenYOLO protocol on the web is significantly more difficult than on Android, but the reward for doing so is ubiquity: OpenYOLO Web can be used on virtually all platforms, and is a viable approach to authenticating on iOS through the use of a SFSafariViewController.</p></div></section><hr class="noprint"><section id="rfc.authors" class="np"><h2><a href="#rfc.authors">Author's Address</a></h2><address><b>Iain McGinniss</b><br>Google, Inc.<br><br>EMail: <a href="mailto:iainmcgin@google.com">iainmcgin@google.com</a></address></section></body></html>